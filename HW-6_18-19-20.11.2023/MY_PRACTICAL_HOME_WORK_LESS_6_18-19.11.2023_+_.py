# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Дата: 18-19 ноября 2023

# Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
# Дисциплина: Основы программирования на Python

# Практическая работа №6.- Функции. Модули, библиотеки и пакеты

# Выполните следующие задания: ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Напишите функцию вычисления (), которая может принимать две переменные и
# вычислять сложение и вычитание. Результат функции должен возвращаться в одном
# обратном вызове.
# Input
# Enter two numbers in one line: 55 6
# Output
# The sum of numbers is 61, the difference of numbers is 49.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓ - старался округлить результат до ближайшего числа.
def calculate_sum_and_difference(num1, num2):
    sum_result = int(num1 + num2)
    difference_result = int(num1 - num2)
    return sum_result, difference_result

# Ввод чисел от пользователя
numbers = input("Введите два числа через пробел: ").split()
num1, num2 = map(float, numbers)

# Вызов функции и вывод результата
sum_result, difference_result = calculate_sum_and_difference(num1, num2)
print(f"The sum of numbers is {sum_result}, the difference of numbers is {difference_result}.")

# Шаг №1.
def calculate_sum_and_difference(num1, num2):
# Определение функции calculate_sum_and_difference, которая принимает два числа (num1 и num2).

# Шаг №2.
sum_result = num1 + num2
difference_result = num1 - num2
# Вычисление суммы (sum_result) и разности (difference_result) двух чисел.

# Шаг №3.
return sum_result, difference_result
# Возврат результатов вычислений в виде кортежа из двух элементов.

# Шаг №4. - Ввод чисел от пользователя
numbers = input("Введите два числа через пробел: ").split()
num1, num2 = map(float, numbers)
# Ввод двух чисел от пользователя в виде строки, разделенной пробелом.
# split() разделяет введенные числа на список строк. map(float, numbers) преобразует строки в числа с плавающей запятой.

# Шаг №5. - Вызов функции и вывод результата
sum_result, difference_result = calculate_sum_and_difference(num1, num2)
# Вызов функции calculate_sum_and_difference с введенными числами.
# Результаты сохраняются в переменные sum_result и difference_result.

# Шаг №6.
print(f"The sum of numbers is {sum_result}, the difference of numbers is {difference_result}.")
# Вывод результатов на экран в желаемом формате, используя форматированную строку (f-string).

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓ - старался округлить результат до ближайшего числа.

def calculate_sum_and_difference(num1, num2):
    return int(num1 + num2), int(num1 - num2)

# Ввод чисел от пользователя и вызов функции
numbers = input("Введите два числа через пробел: ").split()
result = calculate_sum_and_difference(*map(float, numbers))

# Вывод результата
print("The sum of numbers is {}, the difference of numbers is {}.".format(result[0], result[1]))

# Шаг №1. - Определение функции calculate_sum_and_difference:
def calculate_sum_and_difference(num1, num2):
    return int(num1 + num2), int(num1 - num2)
# Здесь определена функция calculate_sum_and_difference, которая принимает два аргумента num1 и num2.
# Функция возвращает кортеж, содержащий сумму и разность чисел, преобразованных в целые значения.

# Шаг №2. - Ввод чисел от пользователя и вызов функции:
numbers = input("Введите два числа через пробел: ").split()
result = calculate_sum_and_difference(*map(float, numbers))
# input("Введите два числа через пробел: "): Запрос у пользователя ввода двух чисел, разделенных пробелом.
# split(): Разделяет введенные числа на отдельные строки и создает список строк.
# map(float, numbers): Преобразует каждую строку из списка в число с плавающей точкой.
# *: Распаковывает значения из итерируемого объекта (в данном случае, из списка чисел) и передает их как аргументы функции calculate_sum_and_difference.
# result: Содержит результаты, возвращенные функцией.

# Шаг №3. - Вывод результата:
print(f"The sum of numbers is {result[0]}, the difference of numbers is {result[1]}.")
# Используется f-строка для вывода результата. Выводится сумма и разность чисел, которые хранятся в кортеже result.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓
def calculate_sum_and_difference(num1, num2):
    return int(num1 + num2), int(num1 - num2)
# Ввод чисел от пользователя
num1, num2 = map(float, input("Введите два числа через пробел: ").split())
# Вызов функции и вывод результата
sum_result, difference_result = calculate_sum_and_difference(num1, num2)
print("The sum of numbers is {}, the difference of numbers is {}.".format(sum_result, difference_result))

# Шаг №1.
def calculate_sum_and_difference(num1, num2):
# Определение функции calculate_sum_and_difference, которая принимает два числа (num1 и num2).

# Шаг №2.
return int(num1 + num2), int(num1 - num2)
# Внутри функции вычисляется сумма (num1 + num2) и разность (num1 - num2) переданных чисел,
# и результаты возвращаются в виде кортежа из двух целых чисел.

# Шаг №3. - Ввод чисел от пользователя
num1, num2 = map(float, input("Введите два числа через пробел: ").split())
# Пользователю предлагается ввести два числа через пробел. input() считывает строку, а split() разбивает ее на
# отдельные строки, создавая список строк. Затем map(float, ...) преобразует каждую строку в число с плавающей запятой,
# и результаты сохраняются в переменных num1 и num2.

# Шаг №4. - Вызов функции и вывод результата
sum_result, difference_result = calculate_sum_and_difference(num1, num2)
# Функция calculate_sum_and_difference вызывается с введенными числами, и результаты сохраняются в
# переменных sum_result и difference_result.

# Шаг №5.
print("The sum of numbers is {}, the difference of numbers is {}.".format(sum_result, difference_result))
# Результаты выводятся на экран с использованием метода форматирования строк format. Фигурные скобки {} в строке
# заменяются значениями переменных sum_result и difference_result.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# Напишите программу, которая создает функцию для списка всех четных чисел от 4 до 30.
# Output: [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]

# Даны четыре действительных числа: x1, y1, x2, y2.
# Напишите функцию distance(x1, y1, x2, y2), вычисляющая расстояние между точкой (x1,y1) и (x2,y2).
# Считайте четыре действительных числа и выведите результат работы этой функции.
# Используйте теорему Пифагора.
# Input
# 4
# 8
# 9
# 6
# Output
# 5.385164807134504

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
def get_even_numbers():
    return [num for num in range(4, 31, 2)]
def distance(x1, y1, x2, y2):
    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5
# Задание № 1: Создание функции для списка четных чисел
even_numbers_list = get_even_numbers()
print("Четные числа от 4 до 30:", even_numbers_list)
# Задание № 2: Функция для вычисления расстояния между точками
x1 = float(input())
y1 = float(input())
x2 = float(input())
y2 = float(input())
result_distance = distance(x1, y1, x2, y2)
print(result_distance)

# Шаг 1. - Создание функции для списка четных чисел
def get_even_numbers():
    return [num for num in range(4, 31, 2)]
# Описание: Функция get_even_numbers создает список четных чисел от 4 до 30 с шагом 2 с
# использованием генератора списков.

# Шаг 2. - Вывод списка четных чисел
even_numbers_list = get_even_numbers()
print("Четные числа от 4 до 30:", even_numbers_list)
# Описание: Функция вызывается, результат (список четных чисел) сохраняется в
# переменной even_numbers_list и выводится на экран.

# Шаг 3. - Функция для вычисления расстояния между точками
def distance(x1, y1, x2, y2):
    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5
# Описание: Функция distance принимает координаты двух точек и использует теорему Пифагора для
# вычисления расстояния между ними.

# Шаг 4. - Ввод координат точек и вызов функции distance
x1 = float(input())
y1 = float(input())
x2 = float(input())
y2 = float(input())

result_distance = distance(x1, y1, x2, y2)
print(result_distance)
# Описание: Пользователю предлагается ввести координаты двух точек.
# Затем функция distance вызывается с введенными координатами, и результат выводится на экран.

# Теперь при вводе:
# 4
# 8
# 9
# 6

# Вы получите ожидаемый результат:
# 5.385164807134504

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №3.

# Дано: ↓

# Дано действительное положительное число a и целое число n. Вычислите a n . Решение оформите в виде функции
# power(a, n). Стандартной функцией возведения в степень пользоваться нельзя.

# Input
# 5
# 6
# Output
# 15625.0

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
def power(a, n):
    result = 1
    for _ in range(abs(n)):
        result *= a
    return 1 / result if n < 0 else result
# Ввод данных
a = float(input())
n = int(input())
# Вызов функции и вывод результата
result_power = power(a, n)
print(result_power)

# Шаг 1. - Определение функции power.
def power(a, n):
    result = 1
    for _ in range(abs(n)):
        result *= a
    return 1 / result if n < 0 else result
# Описание: Функция power принимает два аргумента: действительное положительное число a и целое число n.
# Она использует цикл для вычисления a в степени n и возвращает результат. Если степень n отрицательная,
# результат возвращается в виде дроби.

# Шаг 2. - Ввод данных
a = float(input())
n = int(input())
# Описание: Пользователь вводит действительное положительное число a и целое число n.

# Шаг 3. - Вызов функции и вывод результата
result_power = power(a, n)
print(result_power)
# Функция power вызывается с введенными данными, и результат выводится на экран.

# Теперь, когда пользователь вводит, например:
# 5
# 6

# Программа выведет:
# 15625.0

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
def power(a, n):
    if n == 0:
        return 1
    elif n > 0:
        return a * power(a, n - 1)
    else:
        return 1 / (a * power(a, -n - 1))
# Ввод данных
a = float(input())
n = int(input())
# Вызов функции и вывод результата
result_power = power(a, n)
print(f"{result_power:.1f}")


# Шаг 1. - Определение функции power
def power(a, n):
    if n == 0:
        return 1
    elif n > 0:
        return a * power(a, n - 1)
    else:
        return 1 / (a * power(a, -n - 1))
# Описание: Функция power принимает два аргумента, a и n.
# Она использует рекурсию для вычисления a в степени n в зависимости от значения n.

# Шаг 2. - Ввод данных
# Ввод данных
a = float(input())
n = int(input())
# Описание: Пользователь вводит действительное положительное число a и целое число n.

# Шаг 3. - ВВызов функции и вывод результата с форматированием
# Вызов функции и вывод результата
result_power = power(a, n)
print(f"{result_power:.1f}")

# Описание: Функция power вызывается с введенными данными, и результат выводится на экран с использованием
# форматирования строк (f"{result_power:.1f}"). Это обеспечивает вывод числа с одним знаком после десятичной точки.

# Шаг 4. - Пример выполнения с введенными данными
# Если пользователь вводит:
# 5
# 6
# Рекурсивные вызовы: (возможно я не правильно все расписал)
def power(a, n):
    if n == 0:
        return 1
    elif n > 0:
        return a * power(a, n - 1)
    else:
        return 1 / (a * power(a, -n - 1))
# Вызов power(5, 6):

# Функция возвращает 5 * power(5, 5)
# Вызов power(5, 5):

# Функция возвращает 5 * power(5, 4)
# Вызов power(5, 4):

# Функция возвращает 5 * power(5, 3)
# ... и так далее, до power(5, 1):

# Функция возвращает 5 * power(5, 0)
# Вызов power(5, 0):

# Это базовый случай рекурсии, поскольку n стало равным 0.
# Функция возвращает 1.

# Теперь мы имеем цепочку рекурсивных вызовов:
"power(5, 6) => 5 * power(5, 5) => 5 * (5 * power(5, 4)) => ... => 5 * (5 * (5 * (5 * (5 * (5 * 1)))))"
# Получается, что каждый раз, когда power вызывает саму себя с n - 1, мы перемещаемся к базовому случаю,
# уменьшая n на 1 на каждом шаге. Когда достигается базовый случай (n == 0), рекурсия прекращается,
# и функция возвращает 1.

# Шаг 5. - Вычисление результата:
# 5 * 5 * 5 * 5 * 5 * 1 = 15625

# И наконец! - Вывод результата:
# 15625.0

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №4.

# Дано: ↓

# Напишите программу кошелек.
# Программа будет иметь несколько функций, основные добавление баланса и уменьшение баланса кошелька.
# В теле основной программы, вызовите эти функции, организуя диалог с пользователем.
# У пользователя может быть более двух валют в кошельке.

# Output:
#           *********My purse*********

# Do you want withdraw or deposit money?
# Withdraw

# Enter an amount: 300

# Do you want to check your balance?
# Yes

# Your balance is 450, valuta $

# В случае снятия, проверьте достаточное количество денег на балансе для снятия, иначе выведите сообщение
# пользователю о недостатке суммы.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓ - Алтынбек! =D Здравствуйте! Вы пожалуйста только не снижайте оценку - Я для своего удобства перевел
# все на русский. Надеюсь ВСЕ СДЕЛАЛ правильно! (Я про код)

class Wallet:
    def __init__(self):
        self.balance = 0
        self.currency = "$"  # По умолчанию валюта - доллары

    def deposit(self, amount):
        self.balance += amount
        print(f"Депозит {amount} {self.currency}. Текущий баланс: {self.balance} {self.currency}")

    def withdraw(self, amount):
        if amount <= self.balance:
            self.balance -= amount
            print(f"Вывод {amount} {self.currency}. Текущий баланс: {self.balance} {self.currency}")
        else:
            print("Недостаточно средств. Вывод средств отменен.")

    def check_balance(self):
        print(f"Ваш баланс равен {self.balance} {self.currency}")

def main():
    wallet = Wallet()

    print("*********Мой кошелек*********")
    action = input("Вы хотите снять или внести деньги на счет?\n").lower()

    if action == "внести":
        amount = float(input("Введите сумму: "))
        wallet.deposit(amount)
    elif action == "вывести":
        amount = float(input("Введите сумму: "))
        wallet.withdraw(amount)
    else:
        print("Недопустимое действие. Пожалуйста, выберите 'вывести' или 'внести'.")

    check_balance_response = input("Вы хотите проверить свой баланс?\n").lower()
    if check_balance_response == "да":
        wallet.check_balance()
    else:
        print("Благодарим вас за использование программы КОШЕЛЕК.")

if __name__ == "__main__":
    main()

# Шаг 1. - Создание класса Wallet
class Wallet:
    def __init__(self):
        self.balance = 0
        self.currency = "$"  # По умолчанию валюта - доллары
# В этом шаге мы создаем класс Wallet с атрибутами balance (баланс) и currency (валюта),
# который инициализируется при создании нового кошелька.

# Шаг 2. - Определение функций deposit, withdraw и check_balance
    def deposit(self, amount):
        self.balance += amount
        print(f"Депозит {amount} {self.currency}. Текущий баланс: {self.balance} {self.currency}")

    def withdraw(self, amount):
        if amount <= self.balance:
            self.balance -= amount
            print(f"Вывод {amount} {self.currency}. Текущий баланс: {self.balance} {self.currency}")
        else:
            print("Недостаточно средств. Вывод средств отменен.")

    def check_balance(self):
        print(f"Ваш баланс равен {self.balance} {self.currency}")
# В этом шаге определены три метода класса:
# deposit: для внесения денег на счет.
# withdraw: для снятия денег со счета.
# check_balance: для проверки текущего баланса.

# Шаг 3. - Создание функции main
def main():
    wallet = Wallet()

    print("*********Мой кошелек*********")
    action = input("Вы хотите снять или внести деньги на счет?\n").lower()
# В этом шаге создается основная функция main, в которой создается объект класса Wallet и выводится
# приветственное сообщение.

# Шаг 4. - Обработка действий пользователя
    if action == "внести":
        amount = float(input("Введите сумму: "))
        wallet.deposit(amount)
    elif action == "вывести":
        amount = float(input("Введите сумму: "))
        wallet.withdraw(amount)
    else:
        print("Недопустимое действие. Пожалуйста, выберите 'вывести' или 'внести'.")
# В этом шаге программа спрашивает пользователя, хочет ли он внести или вывести деньги,
# и вызывает соответствующий метод объекта wallet.

# Шаг 5. - Проверка баланса
    check_balance_response = input("Вы хотите проверить свой баланс?\n").lower()
    if check_balance_response == "да":
        wallet.check_balance()
    else:
        print("Благодарим вас за использование программы КОШЕЛЕК.")
# В этом шаге программа спрашивает пользователя, хочет ли он проверить баланс, и вызывает метод check_balance,
# если пользователь согласен.

# Шаг 6. - Запуск основной функции
if __name__ == "__main__":
    main()
# В этом шаге программа запускается, вызывая функцию main, когда файл выполняется как отдельный скрипт.

# Функции ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Выполните следующие задания:~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Написать рекурсивную функцию нахождения степени числа.
# Input:
# Enter numbers: 2 3
# Output:
# 2 to the 3 power is 8
# Решение:


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
def power(base, exponent):
    # Базовый случай: если степень равна 0, возвращаем 1
    if exponent == 0:
        return 1
    # Рекурсивный случай: умножаем число на результат степени на предыдущем уровне
    else:
        return base * power(base, exponent - 1)

# Ввод чисел с клавиатуры
base, exponent = map(int, input("Enter numbers: ").split())

# Вычисление и вывод результата
result = power(base, exponent)
print(f"{base} to the {exponent} power is {result}")

# Шаг 1. - Определение рекурсивной функции power
def power(base, exponent):
    # Базовый случай: если степень равна 0, возвращаем 1
    if exponent == 0:
        return 1
    # Рекурсивный случай: умножаем число на результат степени на предыдущем уровне
    else:
        return base * power(base, exponent - 1)

# power - это функция, которая принимает два аргумента: base (основание) и exponent (степень).
# Внутри функции есть два случая:
# Базовый случай: Если степень exponent равна 0, функция возвращает 1, так как любое число в степени 0 равно 1.
# Рекурсивный случай: В противном случае, функция умножает base на результат того же вызова power,
# но со степенью exponent - 1. Таким образом, мы уменьшаем степень на каждом уровне рекурсии.

# Шаг 2. - Ввод чисел с клавиатуры
base, exponent = map(int, input("Enter numbers: ").split())
# input("Enter numbers: ") запрашивает у пользователя ввод чисел.
# split() разделяет введенные числа по пробелу.
# map(int, ...) преобразует каждую часть введенной строки в целое число.
# base, exponent = ... присваивает значения base и exponent введенным числам.

# Шаг 3. - Вычисление и вывод результата
result = power(base, exponent)
print(f"{base} to the {exponent} power is {result}")
# power(base, exponent) вызывает рекурсивную функцию для вычисления степени числа.
# print(...) выводит результат на экран, используя f-строку для вставки значений переменных base, exponent и result.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# Написать рекурсивную функцию, которая вычисляет сумму всех чисел в диапазоне от a до b. Пользователь вводит a и b.
# Проиллюстрируйте работу функции примером.

# Input:
# Enter numbers: 4 7
# Output:
# Sum from 4 to 7 is 22

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
def sum_range(a, b):
    # Базовый случай: если a > b, возвращаем 0
    if a > b:
        return 0
    # Рекурсивный случай: суммируем текущее число с результатом для следующего числа
    else:
        return a + sum_range(a + 1, b)
# Ввод чисел с клавиатуры
a, b = map(int, input("Enter numbers: ").split())
# Вычисление и вывод результата
result = sum_range(a, b)
print(f"Sum from {a} to {b} is {result}")

# Шаг 1. - Определение рекурсивной функции sum_range
def sum_range(a, b):
    # Базовый случай: если a > b, возвращаем 0
    if a > b:
        return 0
    # Рекурсивный случай: суммируем текущее число с результатом для следующего числа
    else:
        return a + sum_range(a + 1, b)
# sum_range - это функция, которая принимает два аргумента: a и b.
# Внутри функции есть два случая:
# Базовый случай: Если a больше b, функция возвращает 0, так как в диапазоне от a до b нет чисел.
# Рекурсивный случай: В противном случае, функция возвращает сумму текущего числа a и результата того же
# вызова sum_range, но с a + 1 и тем же b.

# Шаг 2. - Ввод чисел с клавиатуры
a, b = map(int, input("Enter numbers: ").split())
# input("Enter numbers: ") запрашивает у пользователя ввод чисел.
# split() разделяет введенные числа по пробелу.
# map(int, ...) преобразует каждую часть введенной строки в целое число.
# a, b = ... присваивает значения a и b введенным числам.

# Шаг 3. - Вычисление и вывод результата
result = sum_range(a, b)
print(f"Sum from {a} to {b} is {result}")
# sum_range(a, b) вызывает рекурсивную функцию для вычисления суммы чисел в диапазоне от a до b.
# print(...) выводит результат на экран, используя f-строку для вставки значений переменных a, b и result.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №3.

# Дано: ↓

# Написать рекурсивную функцию, которая выводит N звезд в ряд, число N задает пользователь.
# Проиллюстрируйте работу функции примером.


# Input:
# Enter amount of stars: 10

# Output:
# * * * * * * * * * *

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
def print_stars_recursive(n):
    # Базовый случай: если n равно 0, завершаем рекурсию
    if n == 0:
        return
    # Рекурсивный случай: выводим звезду и вызываем функцию для n-1
    else:
        print("* ", end="")
        print_stars_recursive(n - 1)

# Ввод числа с клавиатуры
amount = int(input("Enter amount of stars: "))

# Вызов функции и вывод результата
print_stars_recursive(amount)

# Шаг 1. - Определение рекурсивной функции print_stars_recursive
def print_stars_recursive(n):
    # Базовый случай: если n равно 0, завершаем рекурсию
    if n == 0:
        return
    # Рекурсивный случай: выводим звезду и вызываем функцию для n-1
    else:
        print("* ", end="")
        print_stars_recursive(n - 1)
# print_stars_recursive - это функция, которая принимает аргумент n.
# Внутри функции есть два случая:
# Базовый случай: Если n равно 0, функция завершает рекурсию.
# Рекурсивный случай: В противном случае, функция выводит звезду (*) и вызывает саму себя для n-1.

# Шаг 2. - Ввод числа с клавиатуры
amount = int(input("Enter amount of stars: "))
# input("Enter amount of stars: ") запрашивает у пользователя ввод числа звезд.
# int(...) преобразует введенную строку в целое число.
# amount = ... присваивает значение переменной amount введенному числу.

# Шаг 3. - Вызов функции и вывод результата
print_stars_recursive(amount)
# print_stars_recursive(amount) вызывает рекурсивную функцию для вывода указанного количества звезд.
# Функция print_stars_recursive использует print("* ", end=""), чтобы выводить звезды в ряд без перевода
# строки после каждой.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №4.

# Дано: ↓

# Дано действительное положительное число a и целое неотрицательное число n.
# Вычислите an не используя циклы, возведение в степень через ** и функцию math.pow(), а
# используя рекуррентное соотношение an=a⋅an-1. Решение оформите в виде функции power(a, n).

# Input
# 4
# 2
# Output
# 16.0

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
def power(a, n):
    # Базовый случай: если степень n равна 0, возвращаем 1
    if n == 0:
        return 1
    # Рекурсивный случай: умножаем число на результат для степени n-1
    else:
        return a * power(a, n - 1)
# Ввод числа и степени с клавиатуры
a = float(input("Enter a: "))
n = int(input("Enter n: "))

# Вычисление и вывод результата
result = power(a, n)
print(result)

# Шаг 1. - Определение рекурсивной функции power
def power(a, n):
    # Базовый случай: если степень n равна 0, возвращаем 1
    if n == 0:
        return 1
    # Рекурсивный случай: умножаем число на результат для степени n-1
    else:
        return a * power(a, n - 1)
# power - это функция, которая принимает два аргумента: a (основание) и n (степень).
# Внутри функции есть два случая:
# Базовый случай: Если n равно 0, функция возвращает 1, так как a^0 равно 1.
# Рекурсивный случай: В противном случае, функция возвращает произведение
# числа a на результат того же вызова power с a и n-1.

# Шаг 2. - Ввод числа и степени с клавиатуры
a = float(input("Enter a: "))
n = int(input("Enter n: "))
# input("Enter a: ") и input("Enter n: ") запрашивают у пользователя ввод числа и степени соответственно.
# float(...) и int(...) преобразуют введенные строки в числа с плавающей точкой и целые числа соответственно.
# a = ... и n = ... присваивают значения переменным a и n введенным числам.

# Шаг 3. - Вычисление и вывод результата
result = power(a, n)
print(result)
# power(a, n) вызывает рекурсивную функцию для вычисления a^n.





