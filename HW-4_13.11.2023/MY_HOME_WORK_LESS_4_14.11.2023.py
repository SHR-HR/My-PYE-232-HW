# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Дата: 14 ноября 2023

# Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
# Дисциплина: Основы программирования на Python

# Домашнее задание №4.- УПРАВЛЯЮЩИЕ ВЫРАЖЕНИЯ. БЛОКИ, УСЛОВИЯ, ЦИКЛЫ

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Напишите программу, в которой я ввожу целые числа a, b, c.
# Если существует треугольник со сторонами a, b, c, то программа выведет true, иначе false.

# Решение: → (Данные решения и варианты я скопировал из предыдущего домашнего задания №3 - от 10.11.2023
# так как условие одно и тоже) ### Далее я проработаю новые варианты решения данной задачи.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
a, b, c = int(input("Введите a: ")), int(input("Введите b: ")), int(input("Введите c: "))
print("True" if a + b > c and a + c > b and b + c > a else "False")
# Я решил сразу попробовать использовать оператор условного выражения,
# чтобы сделать код более компактным.
# Он проверяет условие a + b > c and a + c > b and b + c > a,
# и возвращает "True", если условие выполняется, и "False" если условие не соблюдено.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# Вариант №2. ↓
a = b = c = int(input("Введите значение a, b и c: "))
# Проверка условий для существования треугольника
if a > 0:
    print("True - Треугольник существует.")
else:
    print("False - Треугольник не существует.")
#Тут я хочу проверить, если значение a больше нуля, и если это так, то выведет "True",
# в противном случае выведет "False".

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# Вариант №3. ↓
a, b, c = int(input("Введите a: ")), int(input("Введите b: ")), int(input("Введите c: "))
# Проверка условий для существования треугольника
print(all([a + b > c, a + c > b, b + c > a]))
# Я написал этот код, чтобы также проверить условия существует ли треугольник,
# но уже с использованием оператора all для более компактной записи.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# Вариант №4. ↓
# Вводим значения сторон (целые числа)
a = int(input("Введите длину стороны a: "))
b = int(input("Введите длину стороны b: "))
c = int(input("Введите длину стороны c: "))
# Далее следует проверка условий для существования треугольника
if (a + b > c) and (a + c > b) and (b + c > a):
    print("True - Треугольник существует.")
else:
    print("False - Треугольник не существует.")
# На этот раз, тут все наглядно просто и понятно. Тут в программе использую оператор and
# для комбинирования условий, проверяя, что каждая пара сторон образует допустимую
# комбинацию для треугольника. Если все три условия выполняются, программа выводит "True", иначе "False".

# Этот Вариант мне подсказала Любовь, сказала, что можно и по просто-му.

# Конечно! В данном случае не стоит забывать об "Таблице истинности".
# Я хотел использовать and и or

# and
# True  and True  -> True
# True  and False -> False
# False and True  -> False
# False and False -> False
#
# or
# True  or True  -> True
# True  or False -> True
# False or True  -> True
# False or False -> False

# Из таблицы истинности видно,
# что оператор and возвращает True только в том случае,
# если оба условия истинны, в противном случае он возвращает False.
# Оператор or возвращает True, если хотя бы одно из условий истинно.

# Если мы используем оба оператора and и or в одном и том же выражении,
# то это может привести к неожиданным результатам,
# так как or может перекрыть результат, даже если первое условие and ложно.

# Вот к примеру такой пример: ↓
a, b, c = int(input("Введите a: ")), int(input("Введите b: ")), int(input("Введите c: "))
# Не рекомендуется использовать оба оператора в одном условии
print((a + b > c and a + c > b) or b + c > a)
# В данном случае, если хотя бы одно из условий (a + b > c and a + c > b) или
# (b + c > a) истинно, то результат будет True.
# Важно понимать, что это не эквивалентно проверке всех трех условий для существования треугольника.
# Лучше использовать только оператор and для корректной проверки всех условий.
print((a + b > c and a + c > b) or b + c > a)
# Если хотя бы одно из условий (a + b > c and a + c > b) и (b + c > a) истинно,
# то результат будет True, что может не соответствовать вашим ожиданиям при проверке
# существования треугольника.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# Вариант №5. ↓
a, b, c = int(input("Введите a: ")), int(input("Введите b: ")), int(input("Введите c: "))
# Проверка условий для существования треугольника
conditions = [a + b > c, a + c > b, b + c > a]
print(all(conditions))
# Тут я попробовал все упростить. Если все верно, то conditions - это же список булевых значений,
# представляющих собой условия для существования треугольника.
# Функция all() возвращает True, если все элементы списка истинны, и False если истины нет.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# Вариант №6.1 ↓
# Можно попробовать сходу использовать условия
def is_triangle(a, b, c):
    if a + b > c and a + c > b and b + c > a:
        return True
    else:
        return False

# Пример использования
a, b, c = map(int, input("Введите три числа через запятую: ").split(','))
result = is_triangle(a, b, c)
print(result)

# !!! ~ ~ ~ ~ ~ ~ Кака я понял → def в языке программирования Python используется для определения функции.
# В данном контексте def - это ключевое слово, которое сообщает интерпретатору Python,
# что следующий блок кода содержит определение функции.

# !!! ~ ~ ~ ~ ~ ~ А 'def is_triangle(a, b, c):' - определяет функцию с именем is_triangle,
# принимающую три параметра a, b и c.
# if a + b > c and a + c > b and b + c > a: - проверяет условие существования треугольника.
# return True - возвращает True, если условие выполнено.
# return False - возвращает False, если условие не выполнено.
# Эта функция 'is_triangle' затем и вызывается с введенными значениями a, b и c для проверки,
# может ли существовать треугольник с данными сторонами.

# !!! ~ ~ ~ ~ ~ ~ 'input("Введите три числа через запятую: ")' - используется для получения ввода от пользователя.
# Пользователь должен ввести три числа, разделенные запятыми.
# 'split(',')' - вызывается на введенной строке и разделяет её на подстроки
# с использованием запятой в качестве разделителя. Результат 'split' представляет собой список строк.
# 'map(int, ...)' - применяет функцию int к каждому элементу списка, чтобы преобразовать его в целое число.
# Затем эти целые числа присваиваются переменным a, b и c.

# Таким образом, если пользователь вводит, например, "6, 7, 8", (как в примере из задачи в дз)
# то переменные a, b и c будут равны соответственно 6, 7 и 8.
# Это позволяет легко работать с введенными числами как с отдельными переменными в дальнейшем коде.

# Можно и не писать именно map и split? И написать код по проще - более понятнее.

# def is_triangle(a, b, c):
#     return a + b > c and a + c > b and b + c > a
#
# try:
#     a = int(input("Введите первое число: "))
#     b = int(input("Введите второе число: "))
#     c = int(input("Введите третье число: "))
#
#     result = is_triangle(a, b, c)
#
#     if result:
#         print("Треугольник существует.")
#     else:
#         print("Треугольник не существует.")
#
# except ValueError:
#     print("Ошибка: Введите корректные целые числа.")

# В этом примере: ↑

# Я получаю каждое число по отдельности с использованием input и int.
# Затем вызываю функцию is_triangle, чтобы проверить, существует ли треугольник с заданными сторонами.
# Вывожу соответствующее сообщение.
# Этот код более явно показывает ввод каждого числа и может быть более понятным для начинающих "кулхацкеров".

# !!! ~ ~ ~ ~ ~ ~ 'return' в Python используется для возврата значения из функции.
# Когда функция выполняет инструкцию return, выполнение функции завершается, и управление
# возвращается вызывающему коду, а значение, указанное в return, передается обратно.

# def is_triangle(a, b, c):
#     return a + b > c and a + c > b and b + c > a

# !!! ~ ~ ~ ~ ~ ~ return a + b > c and a + c > b and b + c > a возвращает булевское значение (True или False)
# в зависимости от того, выполняется ли условие для существования треугольника (a + b > c and a + c > b and b + c > a).

# Когда в основном коде вызывается функция is_triangle(a, b, c), она возвращает True,
# если условие выполнено, и False в противном случае. Значение, возвращенное функцией, присваивается переменной result:

# result = is_triangle(a, b, c)

# После этого значение переменной result используется для определения того,
# существует ли треугольник с заданными сторонами, и выводится соответствующее сообщение:

# if result:
#     print("Треугольник существует.")
# else:
#     print("Треугольник не существует.")

# Таким образом, return позволяет функции возвращать результат своей работы,
# который затем может быть использован в другой части программы.

# !!! ~ ~ ~ ~ ~ ~ 'except ValueError:' - это часть конструкции 'try...except' в языке программирования Python.
# Она используется для обработки исключений, которые могут возникнуть внутри блока try.

# try:
#     a = int(input("Введите первое число: "))
#     b = int(input("Введите второе число: "))
#     c = int(input("Введите третье число: "))
#
#     result = is_triangle(a, b, c)
#
#     if result:
#         print("Треугольник существует.")
#     else:
#         print("Треугольник не существует.")
#
# except ValueError:
#     print("Ошибка: Введите корректные целые числа.")

# 'except ValueError:' означает, что программа будет перехватывать и обрабатывать исключение типа 'ValueError'.
# Это исключение возникает, когда происходит ошибка преобразования типа данных, например,
# при попытке использовать 'int(input(...))', и введенная строка не может быть корректно преобразована в целое число.

# Если внутри блока 'try' происходит исключение типа 'ValueError', выполнение программы переходит в блок except,
# и выполняется код внутри этого блока. В данном случае, программа выводит сообщение об ошибке: "Ошибка:
# Введите корректные целые числа."

# Таким образом, конструкция 'try...except' используется для обработки исключений и предотвращения
# завершения программы из-за ошибок.


# Вариант №6.2 ↓ - Используя короткую форму записи условия
def is_triangle(a, b, c):
    return a + b > c and a + c > b and b + c > a
# Пример использования
a, b, c = map(int, input("Введите три числа через запятую: ").split(','))
result = is_triangle(a, b, c)
print(result)

# Вариант №6.3 ↓ - Используя сортировку (типа метод "кувалда")
def is_triangle(a, b, c):
    sides = [a, b, c]
    sides.sort()
    return sides[0] + sides[1] > sides[2]
# Пример использования
a, b, c = map(int, input("Введите три числа через запятую: ").split(','))
result = is_triangle(a, b, c)
print(result)

# Вариант №6.3 ↓ - Также как Вы и говорили Алтынбек - на уроке про условных тернарных операторов
# Можно записать решение в одну строку, но это может ухудшить читаемость кода, особенно для новичков.
# Вот пример, где обработка исключения также включена в одну строку:
try: result = is_triangle(*(map(int, input("Введите три числа через запятую: ").split(','))))
except ValueError: result = False

print("Треугольник существует." if result else "Треугольник не существует.")

# Здесь мы используем 'try...except' в одну строку. Однако такой код может быть трудным для понимания,
# и его не желательно использовать в реальных проектах, где читаемость кода важна.

# В данном случае, если 'result' равно 'True', будет выведено "Треугольник существует.",
# иначе будет выведено "Треугольник не существует.".

# Условный тернарный оператор имеет следующий синтаксис: → x if условие else y
# где x - результат, если условие истинно, и y - результат, если условие ложно.
# В моем случае, x - "Треугольник существует.", а y - "Треугольник не существует.".

# 'input("Введите три числа через запятую: ").split(',')' - получает ввод от пользователя, разбивает строку по запятой
# и создает список строк, представляющих введенные числа.
# '*' распаковывает элементы списка и передает их как отдельные аргументы функции 'is_triangle'.
# 'map(int, ...)' - применяет функцию 'int' к каждой строке списка, преобразуя ее в целое число.

# Получается, если я все правильно понял то, result будет содержать результат выполнения функции is_triangle,
# примененной к введенным целым числам. Это облегчает передачу нескольких аргументов функции в одной строке кода.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №7 ↓ - Можно так-же использовать функцию 'all'
def is_triangle(a, b, c):
    return all(x > 0 for x in [a, b, c]) and a + b > c and a + c > b and b + c > a

a, b, c = map(int, input("Введите три числа через запятую: ").split(','))
result = is_triangle(a, b, c)
print(result)

# map в Python - это встроенная функция, которая применяет указанную функцию к каждому элементу последовательности
# (например, списка или кортежа) и возвращает итератор, содержащий результаты.
# Синтаксис функции map следующий:
                                  # map(функция, последовательность)
# где функция - это функция, которую мы хотим применить, и последовательность - это последовательность значений,
# к которым эта функция будет применена.

# Пример 1: ↓ - Удвоение каждого элемента списка
numbers = [1, 2, 3, 4, 5]
doubled_numbers = map(lambda x: x * 2, numbers)
print(list(doubled_numbers))  # Вывод: [2, 4, 6, 8, 10]

# 'lambda' в Python - это ключевое слово, которое используется для создания анонимных (безымянных) функций.
# Анонимные функции представляют собой функции, которые могут содержать только одно выражение и не имеют имени.
# Они обычно используются в тех местах, где нужна небольшая, одноразовая функция.
# 'lambda' - это аргументы: выражение

# Пример 2: ↓ - Преобразование строк в числа
strings = ['1', '2', '3', '4', '5']
int_numbers = map(int, strings)
print(list(int_numbers))  # Вывод: [1, 2, 3, 4, 5]

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №8 ↓ - То чувство когда нужно все "разжевать и положить"
def is_triangle(a, b, c):
    """
    Функция, которая проверяет, может ли существовать треугольник с заданными сторонами.

    Параметры:
    - a, b, c: стороны треугольника.

    Возвращает:
    - True, если треугольник существует, иначе False.
    """
    return a + b > c and a + c > b and b + c > a

try:
    # Получаем ввод от пользователя и преобразуем строки в целые числа
    a = int(input("Введите длину первой стороны: "))
    b = int(input("Введите длину второй стороны: "))
    c = int(input("Введите длину третьей стороны: "))

    # Вызываем функцию is_triangle и сохраняем результат
    result = is_triangle(a, b, c)

    # Выводим результат
    if result:
        print("Треугольник существует.")
    else:
        print("Треугольник не существует.")

except ValueError:
    # Обрабатываем ошибку, если введены нечисловые значения
    print("Ошибка: Введите корректные целые числа.")


# !!! ~ ~ ~ ~ ~ ~ Основные моменты:

#1. 'def is_triangle(a, b, c):': Определение функции is_triangle,
# которая принимает три параметра - стороны треугольника.

#2. 'return a + b > c and a + c > b and b + c > a:' Возвращаем 'True',
# если выполняются условия существования треугольника.

#3. 'try:': Начало блока, где мы пытаемся выполнить код. Если возникает ошибка, мы переходим в блок 'except'.

#4. 'a = int(input("Введите длину первой стороны: "))': Получаем ввод пользователя и преобразуем его в целое число.

#5. 'result = is_triangle(a, b, c)': Вызываем функцию 'is_triangle' с введенными значениями и сохраняем результат.

#6. 'if result: ... else: ...': Выводим соответствующее сообщение в зависимости от значения 'result'.

#7. 'except ValueError:': Обрабатываем ошибку, которая возникает, если введены нечисловые значения.

# Вариант №8.1
def is_triangle(a, b, c):
    """
    Функция, которая возвращает True, если существует треугольник с заданными сторонами, иначе False.
    """
    return a + b > c and a + c > b and b + c > a

def main():
    try:
        a = int(input("Введите длину первой стороны: "))
        b = int(input("Введите длину второй стороны: "))
        c = int(input("Введите длину третьей стороны: "))

        result = is_triangle(a, b, c)

        print("Треугольник существует:", result)

    except ValueError:
        print("Ошибка: Введите корректные целые числа.")

if __name__ == "__main__":
    main()

# Разберем подробнее:

def is_triangle(a, b, c):
    """
    Функция, которая возвращает True, если существует треугольник с заданными сторонами, иначе False.
    """
    return a + b > c and a + c > b and b + c > a

# Это определение функции 'is_triangle', которая принимает три аргумента ('a', 'b', 'c') - длины сторон треугольника.
# Внутри функции используется логическое выражение, чтобы определить, существует ли треугольник с данными сторонами.
# Если все три условия выполняются, функция возвращает 'True', иначе - 'False'.

def main():
    try:
        a = int(input("Введите длину первой стороны: "))
        b = int(input("Введите длину второй стороны: "))
        c = int(input("Введите длину третьей стороны: "))

        result = is_triangle(a, b, c)

        print("Треугольник существует:", result)

    except ValueError:
        print("Ошибка: Введите корректные целые числа.")

if __name__ == "__main__":
    main()

# Это определение функции 'main()', которая представляет собой основную часть программы. Внутри 'main()':

# В блоке 'try', мы пытаемся выполнить следующие действия:

# Получить от пользователя три целых числа, представляющих длины сторон треугольника ('a', 'b', 'c').
# Вызвать функцию 'is_triangle' с этими значениями и сохранить результат в переменной 'result'.
# В блоке 'except ValueError:', мы обрабатываем возможное исключение 'ValueError', которое может возникнуть,
# если пользователь ввел нецелое число. В таком случае, программа выведет сообщение об ошибке.
#
# Далее, мы выводим сообщение о существовании треугольника на основе значения 'result',
# полученного от функции 'is_triangle'.
#
# 'if __name__ == "__main__":' - это проверка, которая гарантирует, что блок кода под этим условием будет выполняться
# только в том случае, если этот скрипт запущен напрямую (а не импортирован как модуль в другом скрипте).
# Это часто используется для того, чтобы определить точку входа в программу.
# В данном случае, если скрипт запущен напрямую, вызывается функция 'main()'.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №9 ↓ - с использованием str и f строки.

def is_triangle(a, b, c):
    """
    Функция, которая возвращает True, если существует треугольник с заданными сторонами, иначе False.
    """
    try:
        a = int(a)
        b = int(b)
        c = int(c)
        return a + b > c and a + c > b and b + c > a
    except ValueError:
        return False  # Если введены нечисловые значения, то считаем, что треугольник не существует

def main():
    a = input("Введите длину первой стороны: ")
    b = input("Введите длину второй стороны: ")
    c = input("Введите длину третьей стороны: ")

    if is_triangle(a, b, c):
        print(f"Можно построить треугольник: {True}")
    else:
        print(f"Нельзя построить треугольник: {False}")

if __name__ == "__main__":
    main()


# Теперь разберем каждый блок кода:
#
# 'def is_triangle(a, b, c):': Это определение функции 'is_triangle', которая принимает три аргумента - длины сторон
# треугольника. Внутри функции:
# → Мы используем блок 'try...except', чтобы обработать возможное исключение 'ValueError', которое может возникнуть,
# если введены нечисловые значения.
# → Если значения успешно преобразованы в целые числа, мы проверяем условие существования треугольника.
# → Если значения не могут быть преобразованы, мы считаем, что треугольник не существует.

# 'def main():': Это определение функции 'main', которая представляет основную часть программы. Внутри функции:
# → Мы получаем от пользователя длины сторон в виде строк.
# → Вызываем функцию is_triangle и сохраняем результат в переменной 'is_triangle_result'.
# → С использованием f-строки, мы выводим результат на экран, сообщая, можно ли построить треугольник или нет.

# 'if __name__ == "__main__":': Это условие проверяет, запущен ли скрипт напрямую
# (а не импортирован как модуль в другом скрипте). Если условие выполняется, вызывается функция 'main()'.







# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# Напишите программу, в которой я ввожу число a. Если число, а является четным, то программа выведет true, иначе false.

# Решение: → (Данные решения и варианты я скопировал из предыдущего домашнего задания №3 - от 10.11.2023 так как условие
# одно и тоже) ### Далее я проработаю новые варианты решения данной задачи.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
# Получаем ввод от пользователя
a = int(input("Введите число: "))

# Проверяем, является ли число четным, и выводим результат
if a % 2 == 0:
    print("True")
else:
    print("False")
# Алтынбек, в этом варианте я использовал "процент" - это оператор деления по модулю (или остаточного деления).

# В Python он возвращает остаток от деления левого операнда на правый.
# Например, '5 % 2' вернет '1', потому что при делении 5 на 2 остается остаток 1.

# '==' - это оператор сравнения на равенство. Он используется для проверки, равны ли два значения.
# Если равны, возвращается "True", в противном случае - "False".

# 'a % 2' проверяет остаток от деления введенного числа 'a' на 2.
# Если этот остаток равен 0, то число четное, и программа выводит "True".
# В противном случае, если остаток не равен 0, число нечетное, и программа выводит "False".

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
# Чуть проще с использованием тернарного оператора (пайтон канон)

a = int(input("Введите число a: "))
print("True" if a % 2 == 0 else "False")

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓
# Или так:

a = int(input("Введите число: "))
print(not a & 1)

# Можем использовать "битовой" оператор AND ('&'), поскольку младший бит числа будет установлен в 1
# только для нечетных чисел.
# Как видим: Здесь 'a & 1' проверяет младший бит числа, и результат 'not a & 1' будет 'True' для четных чисел
# и 'False' для нечетных. Опять же, это делает код короче, но может быть менее читаемым для тех,
# кто не знаком с этим приемом.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №4. ↓
# "Темный лес":
a = int(input("Введите число: "))
print(divmod(a, 2)[1] == 0)

# Попробую расписать (подглядывая в интернет):
a = int(input("Введите число: "))
result = divmod(a, 2)  # Используем divmod для получения частного и остатка от деления на 2
is_even = result[1] == 0  # Проверяем, равен ли остаток нулю
print(is_even)

# 'a = int(input("Введите число: "))': Здесь мы просим пользователя ввести число, которое сохраняется в переменной
# 'a. int(input(...))' используется для того, чтобы преобразовать введенное значение в целое число.

# 'result = divmod(a, 2)': Функция 'divmod' в Python принимает два аргумента и возвращает кортеж,
# содержащий частное и остаток от деления этих двух чисел. В данном случае, мы используем её для деления 'a' на 2.

# 'is_even = result[1] == 0': Создается переменная 'is_even'.
# Здесь мы обращаемся к второму элементу кортежа 'result', который представляет собой остаток от деления.
# Затем мы проверяем, равен ли этот остаток нулю. Если да, то 'is_even' становится 'True'
# (потому что остаток от деления на 2 равен 0, что делает число четным), в противном случае она становится 'False'.

# 'print(is_even)': Выводим результат. Если 'is_even' равно 'True', то число четное, и выводится 'True'.
# Если 'is_even' равно 'False', то число нечетное, и выводится 'False'.
#
# Таким образом, 'is_even' является логической переменной, которая хранит информацию о том,
# является ли введенное число четным.
# Мы используем 'divmod' для деления на 2 и получения остатка, а квадратные скобки 'result[1]' обращаются ко
# второму элементу кортежа 'result', который и представляет остаток от деления.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №5. ↓
a = int(input("Введите число: "))
if a % 2 == 0:
    print("Число четное")
elif a % 2 == 1:
    print("Число нечетное")
else:
    print("Число равно 0")
# Получается так, что: ↓
# → 'if a % 2 == 0:' проверяет, является ли число четным.

# → 'elif a % 2 == 1:' проверяет, является ли число нечетным.
# Здесь 'elif' используется для добавления дополнительного условия.

# → else: обрабатывает случай, когда ни одно из предыдущих условий не выполняется.

# Так можно записать этот пример в "тернарном" виде:
a = int(input("Введите число: "))
print("Число четное" if a % 2 == 0 else "Число нечетное")
# Сделаем этот код чуть-чуть короче используя оператор 'or':
a = int(input("Введите число: "))
print(a % 2 == 0 or "Число нечетное")
# Можно попробовать и так:
a = int(input("Введите число: "))
print("Число четное" * (a % 2 == 0) or "Число нечетное")
# Получается, что: ↓
# В этом коде '("Число четное" * (a % 2 == 0))' создает строку "Число четное",
# если условие истинно (число четное), и пустую строку в противном случае.
# Затем оператор 'or' используется для выбора строки "Число нечетное", если первая строка пуста (число нечетное).

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №6. ↓ (56-я минута урока №4)
# Здесь мы уже используем 'and not'
a = int(input("Введите число: "))
print(a % 2 == 0 and not bool(a % 2))

# Здесь 'a % 2 == 0' проверяет, является ли число четным, а 'not bool(a % 2)' проверяет, не является ли число нечетным.
# Но блин, как мне кажется этот код "перебор", так как более простой вариант без использования 'and not'
# затратит меньше ресурсов программы на выполнение задачи.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №7. ↓ - Форматирование строк
a = int(input("Введите число: "))
print("{} является четным: {}".format(a, a % 2 ==0))
#1. Ввод числа: a = int(input("Введите число: "))
#      Здесь я используете функцию 'input()',
#      чтобы запросить у пользователя ввод числа,
#      и затем int() преобразует введенное значение в целое число ('int').
#      Результат сохраняется в переменной 'a'.
#2. Форматирование строки с использованием 'format()': print("{} является четным: {}".format(a, a % 2 == 0))
#      '"{} является четным: {}"' - это строка, в которой фигурные скобки '{}' являются заполнителями для значений,
#      которые будут вставлены в эти места.
#      '.format(a, a % 2 == 0)' - это метод строки 'format()', который заменяет фигурные скобки
#      соответствующими значениями. Здесь a вставляется в первую пару фигурных скобок, а 'a % 2 == 0'
#      (результат проверки четности) - во вторую пару.
#3. Вывод строки: print("{} является четным: {}".format(a, a % 2 == 0))
#      * - Этот print выводит сформированную строку в консоль.

# Это форматирование строк позволяет вам встраивать значения переменных в строки более читаемым и гибким способом.
# Функция 'format()' может принимать несколько аргументов и располагать их в порядке, указанном в строке.
# Также, с использованием f-строк, этот код может быть переписан более компактным образом:

# print(f"{a} является четным: {a % 2 == 0}")

#      Здесь 'f"{a} является четным: {a % 2 == 0}"' - это f-строка, где переменные в фигурных скобках подставляются
#      непосредственно в строку.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №8. ↓ - f-строки
a = int(input("Введите число: "))
print(f"{a} является четным: {a % 2 == 0}")

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №9. ↓ - Использование логического значения напрямую (так сказать сразу в лоб)
a = int(input("Введите число: "))
print(a % 2 == 0)
#      Почему именно так, а не иначе:
     # Оператор '%' (остаток от деления): В Python оператор '%' возвращает остаток от деления одного числа на другое.
     # Если результат этого выражения равен 0, то число четное, иначе - нечетное.
     # Сравнение с 0: Выражение 'a % 2 == 0' проверяет, равен ли остаток от деления 'a' на '2' нулю.
     # Если равен, то выводится 'True', иначе - 'False'.

# Этот код компактно и эффективно определяет, является ли введенное число четным или нечетным,
# и выводит соответствующее логическое значение. Важно отметить, что четность числа связана с тем,
# делится ли оно на 2 без остатка, и поэтому проверка 'a % 2 == 0' является стандартным
# способом определения четности в программировании.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №10. ↓ - Использование логического оператора not
a = int(input("Введите число: "))
print(not a % 2)
# Вместо явной проверки на четность можно использовать оператор not,
# чтобы инвертировать результат проверки на нечетность.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №11. ↓ - Использование деления на 2
a = int(input("Введите число: "))
print(a // 2 * 2 == a)

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №3.

# Дано: ↓

# Напишите программу, в которой я ввожу три целостных чисел a, b и c,
# и если сумма a и b больше c, то программа выведет true, иначе false.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓ - Банальный вариант решения
# Ввод трех целых чисел
a = int(input("Введите целое число a: "))
b = int(input("Введите целое число b: "))
c = int(input("Введите целое число c: "))

# Проверка условия и вывод результата
result = a + b > c
print(result)

# В этом коде:

# 'a, b, и c' - это переменные, в которых сохраняются введенные пользователем целые числа с помощью функции 'input'
# и преобразования в целые числа с помощью 'int'.

# 'a + b > c' - это условное выражение, которое проверяет, является ли сумма 'a' и 'b' больше 'c'.
# Результат этого выражения (логическое значение 'True' или 'False') сохраняется в переменной 'result'.

# 'print(result)' - выводит результат на экран. Если сумма 'a' и 'b' больше 'c', то будет выведено 'True',
# иначе - 'False'.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓ - Ну просто Doctor Strange какой-то
# Ввод трех целых чисел
a = int(input("Введите целое число a: "))
b = int(input("Введите целое число b: "))
c = int(input("Введите целое число c: "))

result = (a + b - c) >> 31 == 0
print(result)

# А теперь пошагово:
            # Этот пример использует "битовую магию" для выполнения условия задачи. Вот пошаговое объяснение:
            #1. 'a = int(input("Введите целое число a: "))': Запрашивает у пользователя ввод целого числа 'a'.

            #2. 'b = int(input("Введите целое число b: "))': Запрашивает у пользователя ввод целого числа 'b'.

            #3. 'c = int(input("Введите целое число c: "))': Запрашивает у пользователя ввод целого числа 'c'.

# Теперь вот строка, где используется "битовая магия":
            # result = (a + b - c) >> 31 == 0

            #1. '(a + b - c)': Вычисляет разницу между суммой 'a' и 'b' и 'c'.

            #2. '>> 31': Это битовый сдвиг вправо на 31 бит.
            # В этом контексте это используется для извлечения старшего бита (знакового бита) числа.
            # Если результат отрицателен, старший бит будет установлен в 1, иначе в 0.

            #3. '== 0': Сравнивает полученное значение с нулем.

# Итак, если сумма 'a' и 'b' больше 'c', то результат будет положительным числом,
# и старший бит (31-й бит) будет равен 0. Таким образом, выражение '(a + b - c) >> 31 == 0' возвращает 'True' в случае,
# если условие "сумма a и b больше c" выполняется, и 'False' в противном случае.

# Относительно числа 31: в данном контексте используется 31, потому что это количество битов в 32-битных целых числах
# (включая знаковый бит).

            # Разберемся подробнее:
            #1. >> - это битовый сдвиг вправо. В данном случае '(a + b - c) >> 31' означает,
            # что мы сдвигаем биты вправо на 31 позицию. Это аналогично делению на 2^31
            # (поскольку каждый битовый сдвиг вправо на 1 позицию эквивалентен делению на 2).

            #2. '== 0' - это проверка равенства нулю. Таким образом, '(a + b - c) >> 31 == 0' означает,
            # что мы проверяем, равно ли выражение '(a + b - c)' нулю после битового сдвига вправо на 31 бит.

# Почему именно 31?

# В данном случае, вероятно, используется для проверки старшего бита, который является знаковым битом в 32-битных
# целых числах. Если число отрицательное, то старший бит равен 1.
# Если число положительное или ноль, то старший бит равен 0.

# Таким образом, выражение '(a + b - c) >> 31 == 0' фактически проверяет, является ли результат
# (сумма 'a' и 'b' минус 'c') положительным или нулевым. Если да, то результат равен 'True', иначе 'False'.

# Такой способ использования битовых операций иногда называют "битовой магией",
# поскольку он может казаться сложным или непонятным на первый взгляд, но при этом обеспечивает эффективный способ
# выполнения определенных операций.

                 # В выражении 2^31, символ ^ не обозначает возведение в степень,
                 # как это делает в некоторых языках программирования. В Python и многих
                 # других языках программирования ^ обозначает побитовое исключающее ИЛИ (XOR).#

                 # Итак, 2^31 означает, что биты 2 и 31 будут переключены (если они разные),
                 # что приведет к результату 29 (бинарное представление 2 в десятичной системе - 10, а 31 - 11111).

                 # Если вы хотите вычислить 2 в степени 31, то это делается с использованием оператора '**':
                 # result = 2 ** 31
                 # print(result)

# В данном контексте, '2 ** 31' означает 2 в степени 31, что равно 2147483648.
# Это число является максимальным значением для 32-битных целых чисел со знаком (от -2147483648 до 2147483647),
# и, возможно, это связано с выбором числа 31 в вашем исходном коде, где производится битовый сдвиг.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓ - снова логический опретор not

a = int(input("Введите целое число a: "))
b = int(input("Введите целое число b: "))
c = int(input("Введите целое число c: "))

result = not (a + b <= c)
print(result)

# Разберем этот код пошагово:

#1. 'a = int(input("Введите целое число a: "))': Запрашивает у пользователя ввод целого числа 'a'
# и преобразует его в целое число с помощью 'int()'.

#2. 'b = int(input("Введите целое число b: "))': Запрашивает у пользователя ввод целого числа 'b'
# и преобразует его в целое число.

#3. 'c = int(input("Введите целое число c: "))': Запрашивает у пользователя ввод целого числа 'c'
# и преобразует его в целое число.

#4. 'result = not (a + b <= c)': Вычисляет сумму 'a' и 'b', затем проверяет, больше ли эта сумма 'c'.
# Если сумма 'a' и 'b' больше 'c', то '(a + b <= c)' будет равно 'False', и 'not False' будет 'True'.
# Если сумма меньше или равна 'c', то '(a + b <= c)' будет 'True', и 'not True' будет 'False'.

#5. 'print(result)': Выводит результат на экран. Таким образом, если сумма 'a' и 'b' больше 'c',
# то выводится 'True', иначе 'False'.

        # Таким образом, весь этот код фактически решает задачу:
        # если сумма 'a' и 'b' больше 'c', то результат будет 'True', иначе 'False'.
        # Оператор 'not' используется для инверсии значения, полученного из сравнения.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №4. ↓ - Тернарный оператор
a = int(input("Введите целое число a: "))
b = int(input("Введите целое число b: "))
c = int(input("Введите целое число c: "))

result = True if a + b > c else False
print(result)

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №5. ↓ - Понимание all и list
a = int(input("Введите целое число a: "))
b = int(input("Введите целое число b: "))
c = int(input("Введите целое число c: "))

result = all([a + b > c])
print(result)

# В данном коде используется функция all() для проверки, является ли все элементы в передаваемом ей итерируемом
# объекте истинными. В данном случае передается список с одним элементом - результатом сравнения a + b > c.

        #1. a = 'int(input("Введите целое число a: "))': Запрашивает у пользователя ввод целого числа 'a'
            # и преобразует его в целое число.

        #2. 'b = int(input("Введите целое число b: "))': Запрашивает у пользователя ввод целого числа 'b'
            # и преобразует его в целое число.

        #3. 'c = int(input("Введите целое число c: "))': Запрашивает у пользователя ввод целого числа 'c'
            # и преобразует его в целое число.

        #4. 'result = all([a + b > c])': Создается список с одним элементом - результатом сравнения 'a' + 'b' > 'c'.
            # Функция 'all()' возвращает 'True', если все элементы в переданном ей списке истинны.
            # В данном случае, если 'a + b > c', то 'result' будет 'True', иначе 'False'.

        #5. 'print(result)': Выводит результат на экран. Если сумма 'a' и 'b' больше 'c',
            # то выводится 'True', иначе 'False'.

# В целом, использование 'all()' здесь может показаться избыточным, поскольку проверка одного условия достаточна,
# и вместо этого можно было бы просто использовать 'result = a + b > c'.
# Однако, если вам нужно проверить более сложные условия, 'all()' может быть полезной функцией.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №6. ↓ - Функция min в действии
a = int(input("Введите целое число a: "))
b = int(input("Введите целое число b: "))
c = int(input("Введите целое число c: "))

result = min(a + b, c) == a + b
print(result)

# И так:
        # Шаги - 1, 2, 3, ↓ 5- похожи.
        #4. 'result = min(a + b, c) == a + b': Функция 'min(a + b, c)' возвращает
            # минимальное значение из 'a + b' и 'c'. Затем это минимальное значение сравнивается с 'a + b'.
            # Если они равны, то 'result' будет 'True', иначе 'False'.
# Таким образом, код проверяет, является ли сумма 'a + b' минимальной среди 'a + b' и 'c'.
# Если да, то результат будет 'True', в противном случае 'False'.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №7. ↓ - Использование лямбда-функции:
a, b, c = map(int, input("Введите три целых числа через пробел: ").split())
print((lambda x, y, z: x + y > z)(a, b, c))

# Данный код использует анонимную (lambda) функцию в сочетании с функцией 'map()' для преобразования ввода
# пользователя в три целых числа. Давайте разберем его по шагам:

    #1. 'input("Введите три целых числа через пробел: ")': Запрашивает у пользователя ввод трех
    # целых чисел, разделенных пробелами.

    #2. '.split()': Разделяет введенную строку на подстроки по пробелам, создавая список строк.

    #3. 'map(int, ...)': Применяет функцию 'int()' ко всем элементам полученного списка,
    # преобразуя каждую строку в целое число.

    #4. 'a, b, c = ...': Распаковывает полученные три целых числа из списка и присваивает их переменным 'a', 'b', и 'c'.

    #5. '(lambda x, y, z: x + y > z)': Это анонимная (lambda) функция, которая принимает три аргумента 'x', 'y' и 'z'
    #  и возвращает булево значение 'x' + 'y' > 'z'.

    #6. '(a, b, c)': Передает значения переменных 'a', 'b' и 'c' в анонимную функцию.

    #7. 'print(...)': Выводит результат выполнения анонимной функции на экран.
    # Если 'a + b > c', то будет выведено 'True', иначе 'False'.

# Таким образом, данный код позволяет пользователю ввести три целых числа через пробел и проверяет,
# является ли сумма первых двух чисел больше третьего числа.

# Еще раз:
            # '(lambda x, y, z: x + y > z)' — это анонимная (или лямбда-) функция.
            # Эта функция принимает три аргумента 'x', 'y', и 'z', и возвращает булево значение,
            # которое равно результату сравнения 'x + y > z'.

            # Так что, 'x + y > z' является телом этой функции.
            # Здесь 'x', 'y' и 'z' — это параметры функции, и в данном контексте они предполагаются переменными,
            # которые были переданы функции в момент её вызова.
            # Таким образом, выражение 'x + y > z' означает "сумма 'x' и 'y' больше 'z'".
# Вернемся к примеру:
(lambda x, y, z: x + y > z)(a, b, c)
# В этом случае 'a', 'b' и 'c' — это значения, которые передаются в качестве аргументов функции.
# Таким образом, если 'a + b > c', функция вернет 'True', иначе вернет 'False'.
# После этого результат сразу выводится на экран с помощью 'print'.
#
# Так что, x, y и z - это просто имена параметров функции, и в данном случае, они представляют значения,
# переданные при вызове функции.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №8. ↓
def is_sum_greater(a, b, c):
    return a + b > c

# Ввод трех целых чисел от пользователя
a = int(input("Введите значение a: "))
b = int(input("Введите значение b: "))
c = int(input("Введите значение c: "))

# Вывод результата с использованием функции
print(is_sum_greater(a, b, c))

# В этом примере создана функция 'is_sum_greater', которая принимает три аргумента и возвращает булево значение,
# указывающее, является ли сумма первых двух чисел больше третьего.
# Затем программа вызывает эту функцию с введенными значениями и выводит результат.

# Этот подход делает код более модульным и легко читаемым,
# что может быть полезно при работе с более сложными программами.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №9. ↓
class SumChecker:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def is_sum_greater(self):
        return self.a + self.b > self.c

# Ввод трех целых чисел от пользователя
a = int(input("Введите значение a: "))
b = int(input("Введите значение b: "))
c = int(input("Введите значение c: "))

# Создание экземпляра класса и вызов метода
checker = SumChecker(a, b, c)
print(checker.is_sum_greater())

# Тут можно попробовать создать класс 'SumChecker', содержащий атрибуты 'a', 'b', и 'c', и метод 'is_sum_greater',
# который выполняет проверку. Затем программа создает экземпляр этого класса,
# передавая введенные пользователем значения, и вызывает метод для проверки условия.
#
# Такой подход полезен, если у вас есть сложные структуры данных или вы хотите
# добавить дополнительную функциональность в будущем, такую как проверки наличия чисел, обработку исключений и т. д.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №10. ↓

class BankAccount:
    def __init__(self, account_holder, balance=0):
        self.account_holder = account_holder
        self.balance = balance

    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
            print(f"Депозит в размере {amount} выполнен. Новый баланс: {self.balance}")
        else:
            print("Сумма депозита должна быть положительной.")

    def withdraw(self, amount):
        if 0 < amount <= self.balance:
            self.balance -= amount
            print(f"Снятие средств в размере {amount} выполнено. Новый баланс: {self.balance}")
        else:
            print("Недостаточно средств или сумма для снятия должна быть положительной.")

    def check_balance(self):
        print(f"Текущий баланс: {self.balance}")


def main():
    account_holder_name = input("Введите имя владельца счета: ")
    initial_balance = float(input("Введите начальный баланс счета: "))

    account = BankAccount(account_holder_name, initial_balance)

    while True:
        print("\nВыберите действие:")
        print("1. Внести депозит")
        print("2. Снять средства")
        print("3. Проверить баланс")
        print("4. Выйти из программы")

        choice = input("Введите номер действия: ")

        if choice == '1':
            deposit_amount = float(input("Введите сумму депозита: "))
            account.deposit(deposit_amount)
        elif choice == '2':
            withdraw_amount = float(input("Введите сумму для снятия: "))
            account.withdraw(withdraw_amount)
        elif choice == '3':
            account.check_balance()
        elif choice == '4':
            print("Программа завершена.")
            break
        else:
            print("Неверный выбор. Пожалуйста, выберите снова.")


if __name__ == "__main__":
    main()

# разберем код поэтапно и обсудим каждый его элемент:
class BankAccount:
    def __init__(self, account_holder, balance=0):
        self.account_holder = account_holder
        self.balance = balance
# 'class BankAccount': Здесь создается класс 'BankAccount', который будет представлять банковский счет.

# '__init__': Это конструктор класса. Метод '__init__' вызывается при создании нового объекта этого класса.
# В данном случае, он принимает параметры 'account_holder' (владелец счета) и 'balance' (баланс счета),
# устанавливает их в атрибуты объекта.


    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
            print(f"Депозит в размере {amount} выполнен. Новый баланс: {self.balance}")
        else:
            print("Сумма депозита должна быть положительной.")

# 'def deposit(self, amount):': Это метод класса BankAccount, который позволяет внести депозит на счет.
# Принимает параметр amount (сумма депозита).

# 'if amount > 0:': Проверяет, что сумма депозита положительна.

# 'self.balance += amount': Увеличивает баланс счета на сумму депозита.

# 'print(f"Депозит в размере {amount} выполнен. Новый баланс: {self.balance}")':
# Выводит информацию о выполненном депозите.

# 'else:': В случае, если сумма депозита не положительна, выводит сообщение об ошибке.


    def withdraw(self, amount):
        if 0 < amount <= self.balance:
            self.balance -= amount
            print(f"Снятие средств в размере {amount} выполнено. Новый баланс: {self.balance}")
        else:
            print("Недостаточно средств или сумма для снятия должна быть положительной.")

# 'def withdraw(self, amount):': Метод для снятия средств со счета. Принимает параметр amount (сумма для снятия).

# 'if 0 < amount <= self.balance:': Проверяет, что сумма для снятия положительна и не превышает текущий баланс.

# 'self.balance -= amount': Уменьшает баланс счета на сумму снятия.

# 'print(f"Снятие средств в размере {amount} выполнено. Новый баланс: {self.balance}")':
# Выводит информацию о выполненном снятии средств.

# 'else:': В случае, если условие для снятия средств не выполняется, выводит сообщение об ошибке.


    def check_balance(self):
        print(f"Текущий баланс: {self.balance}")

# 'def check_balance(self):': Метод для проверки текущего баланса.

# 'print(f"Текущий баланс: {self.balance}")': Выводит информацию о текущем балансе.


def main():
    account_holder_name = input("Введите имя владельца счета: ")
    initial_balance = float(input("Введите начальный баланс счета: "))

    account = BankAccount(account_holder_name, initial_balance)

    while True:
# ... (блок кода обработки выбора пользователя)

# 'def main():': Это функция, которая является точкой входа в программу.

# 'account_holder_name = input("Введите имя владельца счета: ")': Получает от пользователя имя владельца счета.

# 'initial_balance = float(input("Введите начальный баланс счета: "))': Получает от пользователя начальный баланс счета.

# 'account = BankAccount(account_holder_name, initial_balance)': Создает объект класса BankAccount с введенными данными.

# 'while True:': Бесконечный цикл для взаимодействия с пользователем.


# Обработка выбора пользователя в цикле:
        choice = input("Введите номер действия: ")

        if choice == '1':
            deposit_amount = float(input("Введите сумму депозита: "))
            account.deposit(deposit_amount)
        elif choice == '2':
            withdraw_amount = float(input("Введите сумму для снятия: "))
            account.withdraw(withdraw_amount)
        elif choice == '3':
            account.check_balance()
        elif choice == '4':
            print("Программа завершена.")
            break
        else:
            print("Неверный выбор. Пожалуйста, выберите снова.")

# 'choice = input("Введите номер действия: ")': Получает от пользователя номер выбранного действия.

# 'if choice == '1':, elif choice == '2':', и так далее: Определяет,
# какое действие выполнить в зависимости от выбора пользователя.

# 'account.deposit(deposit_amount)', 'account.withdraw(withdraw_amount)', и так далее:
# Вызывают соответствующий метод объекта 'account' в зависимости от выбора пользователя.


# Завершение программы:
if __name__ == "__main__":
    main()

# 'if __name__ == "__main__":': Этот блок кода обеспечивает выполнение функции 'main()',
# только если скрипт запущен как основная программа, а не импортирован как модуль в другой программе.
# Это позволяет избежать выполнения кода при импорте в другие скрипты.


# Компактное решение:
class BankAccount:
    def __init__(self, a, b, c):
        self.account_holder = a
        self.balance = b + c

    def is_sum_greater(self):
        return self.balance > self.account_holder


def main():
    a, b, c = map(int, input("Введите три целых числа через пробел: ").split())
    account = BankAccount(a, b, c)
    print(account.is_sum_greater())


if __name__ == "__main__":
    main()

# 'BankAccount' создает объект банковского счета с учетом начального баланса и владельца счета.
# 'is_sum_greater' проверяет, является ли сумма баланса и владельца счета больше владельца счета.
# В функции 'main' пользователь вводит три целых числа, которые затем передаются в 'BankAccount',
# и выводится результат проверки.

# Или так:
class BankAccount:
    def __init__(self, a, b, c):
        self.balance = b + c
        self.is_sum_greater = self.balance > a


if __name__ == "__main__":
    a, b, c = map(int, input("Введите три целых числа через пробел: ").split())
    account = BankAccount(a, b, c)
    print(account.is_sum_greater)

# Как вариант:
class BankAccount:
    def __init__(self, a, b, c):
        self.is_sum_greater = (lambda x, y, z: (y + z) > x)(a, b, c)
# Этот код использует анонимную функцию 'lambda', чтобы выполнить проверку в пределах одной строки.
# Но я выше уже описывал лямбду.
# Однако стоит отметить, что такие конструкции могут сделать код менее читаемым для других разработчиков.
# Важно находить баланс между краткостью и читаемостью кода.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Бонус варианты - для решения задачи. ↓ - Это примеры - после прошествия урока №5. (15.11.2023)

# Использование import math:
import math

class BankAccount:
    def __init__(self, a, b, c):
        self.is_sum_greater = math.isqrt(a**2 + b**2) > c
# Пример использования
account = BankAccount(4, 5, 6)
print(account.is_sum_greater)  # Выведет True

# В данном коде используется модуль math для выполнения операции квадратного корня.
import math
# Эта строка кода импортирует модуль math, который предоставляет различные математические функции,
# включая функцию isqrt (integer square root - квадратный корень для целых чисел).
class BankAccount:
    def __init__(self, a, b, c):
        self.is_sum_greater = math.isqrt(a**2 + b**2) > c
# Эта часть кода определяет класс 'BankAccount', в конструкторе которого (метод '__init__')
# инициализируется атрибут 'is_sum_greater'.
# Значение этого атрибута определяется сравнением квадратного корня суммы квадратов 'a' и 'b' с числом 'c'.
    # 'a**2' + 'b**2': Это сумма квадратов 'a' и 'b'.
    # 'math.isqrt(a**2 + b**2)': Это квадратный корень из суммы квадратов 'a' и 'b', полученный с использованием
    # функции 'isqrt' из модуля 'math'.
    # 'math.isqrt(a**2 + b**2) > c': Это логическое сравнение: если квадратный корень суммы квадратов 'a' и 'b'
    # больше 'c', то атрибуту 'is_sum_greater' присваивается значение 'True', иначе - 'False'.
# Пример использования
account = BankAccount(4, 5, 6)
print(account.is_sum_greater)  # Выведет True
# В этой части кода создается снова объект account класса 'BankAccount' с
# параметрами 'a=4', 'b=5', 'c=6'. После этого выводится значение атрибута 'is_sum_greater',
# которое в данном случае будет 'True', так как 4^2 + 5^2 = 41, и квадратный корень из 41 больше 6.

# ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
# Использование функции range:
class BankAccount:
    def __init__(self, a, b, c):
        self.is_sum_greater = any(a + b > x for x in range(c))
# Пример использования
account = BankAccount(4, 5, 20)
print(account.is_sum_greater)  # Выведет False

# Этот код определяет класс 'BankAccount', в конструкторе которого (метод '__init__')
# инициализируется атрибут 'is_sum_greater'.
# Значение этого атрибута определяется с использованием функции 'any', которая возвращает 'True',
# если хотя бы один элемент в итерируемом объекте истинен, иначе возвращает 'False'.

# 'for x in range(c)': Это цикл 'for', который проходит по значениям от 0 до 'c-1'.
# 'a + b > x': Это логическое выражение, проверяющее, является ли сумма 'a' и 'b' больше текущего значения x.
# 'any(a + b > x for x in range(c))': Это использование функции 'any' для проверки,
# что условие 'a + b > x' выполняется хотя бы для одного значения 'x' в диапазоне от 0 до 'c-1'.
# Пример использования
account = BankAccount(4, 5, 20)
print(account.is_sum_greater)  # Выведет False

# В этой части кода создается объект 'account' класса 'BankAccount' с параметрами 'a=4', 'b=5', 'c=20'.
# Затем выводится значение атрибута 'is_sum_greater', которое в данном случае будет 'False',
# так как ни для одного значения 'x' в диапазоне от 0 до 19 условие 'a + b > x' не выполняется.

# ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
# С пост-условием do-while:
class BankAccount:
    def __init__(self, a, b, c):
        self.is_sum_greater = False
        while True:
            if a + b > c:
                self.is_sum_greater = True
            break
# Пример использования
account = BankAccount(4, 5, 6)
print(account.is_sum_greater)  # Выведет True

#Тут у нас опять код определяет класс 'BankAccount', в конструкторе которого (метод '__init__') инициализируется
# атрибут 'is_sum_greater'. Значение этого атрибута определяется с использованием цикла while с пост-условием.

# 'while True:': Это бесконечный цикл, который будет выполняться до тех пор,
# пока не будет прерван с помощью оператора break.

# 'if a + b > c:': Это условие, проверяющее, является ли сумма 'a' и 'b' больше 'c'.

# 'self.is_sum_greater = True': Если условие выполняется, устанавливается значение 'True' для атрибута 'is_sum_greater'.

# 'break': Этот оператор прерывает выполнение цикла, даже если он является бесконечным.
# Пример использования
account = BankAccount(4, 5, 6)
print(account.is_sum_greater)  # Выведет True
# Ну уже и ежу понятно, что тут создается объект 'account' класса 'BankAccount' с параметрами 'a=4', 'b=5', 'c=6'.
# Так как сумма 'a' и 'b' (4 + 5) больше 'c' (6), условие выполняется, и атрибуту 'is_sum_greater' присваивается
# значение 'True'.

# ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
# С пред-условием while
class BankAccount:
    def __init__(self, a, b, c):
        self.is_sum_greater = False
        while a + b > c:
            self.is_sum_greater = True
            break
# Пример использования
account = BankAccount(4, 5, 20)
print(account.is_sum_greater)  # Выведет False

# Ну и уже по "традиции": этот код определяет класс 'BankAccount', в конструкторе которого (метод '__init__')
# инициализируется атрибут 'is_sum_greater'. Значение этого атрибута определяется с использованием
# цикла 'while' с пред-условием.

# 'while a + b > c:': Это пред-условие цикла, который будет выполняться, пока условие 'a + b > c' верно.

# 'self.is_sum_greater = True': Если условие выполняется (т.е., сумма 'a' и 'b' больше 'c'),
# устанавливается значение 'True' для атрибута 'is_sum_greater'.

# 'break': Этот оператор прерывает выполнение цикла, даже если условие было истинным,
# что делает цикл выполняющимся не более одного раза.
# Пример использования
account = BankAccount(4, 5, 20)
print(account.is_sum_greater)  # Выведет False

# В этой части кода создается объект 'account' класса 'BankAccount' с параметрами 'a=4', 'b=5', 'c=20'.
# Так как сумма 'a' и 'b' (4 + 5) не больше 'c' (20), условие цикла не выполняется,
# и значение атрибута 'is_sum_greater' остается 'False'.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №4.

# Дано: ↓

# Напишите программу, в которой я ввожу два целостных числа, и если первое число больше второго,
# то программа выведет true, иначе false.

# Решение: ↓
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
def compare_numbers(a, b):
    return a > b
# Пример использования
numbers1 = map(int, input("Введите два целых числа через пробел: ").split())
numbers2 = map(int, input("Введите еще два целых числа через пробел: ").split())

result1 = compare_numbers(*numbers1)
result2 = compare_numbers(*numbers2)

print(result1, result2)

# Подробнее:
def compare_numbers(a, b):
    return a > b
# Это определение функции 'compare_numbers'. Эта функция принимает два аргумента ('a' и 'b') и возвращает 'True',
# если a больше 'b', то в противном случае 'False'.
numbers1 = map(int, input("Введите два целых числа через пробел: ").split())
numbers2 = map(int, input("Введите еще два целых числа через пробел: ").split())
# В этих строках кода пользователь вводит два набора целых чисел через пробел с использованием функции 'input'.
# Затем 'split()' разбивает введенные значения на отдельные строки, и 'map(int, ...)' преобразует строки в целые числа.
result1 = compare_numbers(*numbers1)
result2 = compare_numbers(*numbers2)
# А это для того, чтобы вызывать функцию 'compare_numbers' с передачей ей значения из первого и второго наборов чисел.
# Знак '*' перед 'numbers1' и 'numbers2' распаковывает их значения, чтобы передать их в виде аргументов функции.
print(result1, result2)
# Ну и наконец, результаты сравнения выводятся на экран.
# Если 'result1' равно 'True', то первый введенный набор чисел больше;
# если 'result1' равно 'False', то первый введенный набор чисел не больше. То же самое относится к 'result2'.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
print(*map(lambda x, y: x > y, map(int, input("Введите два целых числа через пробел: ").split())))

# 'input("Введите два целых числа через пробел: ")': Запрашивает у пользователя ввод двух целых чисел через пробел.
# '.split()': Разбивает введенную строку на список строк, используя пробел в качестве разделителя.
# 'map(int, ...)': Применяет функцию 'int' к каждой строке в полученном списке, преобразуя строки в целые числа.

# 'lambda x, y: x > y': Это анонимная (лямбда) функция, которая принимает два аргумента 'x' и 'y' и возвращает 'True',
# если 'x' больше 'y', то 'False'.

# "map(lambda x, y: x > y, ...)": Применяет лямбда-функцию к парам целых чисел из предыдущего шага,
# создавая итератор булевых значений.

# '*': Распаковывает элементы итератора, превращая их в аргументы функции 'print'.
# 'print(...)': Выводит результаты сравнения на экран.

# Таким образом, ввод пользователя преобразуется в два целых числа, затем они сравниваются,
# и результаты выводятся на экран в одну строку кода.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓
numbers = map(int, input("Введите два целых числа через пробел: ").split())
print(numbers[0] > numbers[1])
# Тут от части все также но все равно напишу:

# 'input("Введите два целых числа через пробел: ")': Эта часть кода запрашивает
# у пользователя ввод двух целых чисел через пробел.

# '.split()': Метод 'split()' разбивает введенную строку на список строк, используя пробел в качестве разделителя.
# Например, если пользователь вводит "4 7", то это будет преобразовано в список '['4', '7']'.

# 'map(int, ...)': Функция 'map()' применяет функцию 'int' к каждой строке в полученном списке.
# Это преобразует строки в целые числа.

# 'numbers = ...': Эта строка кода создает объект 'numbers', который представляет собой итератор целых чисел,
# полученных из введенных данных.

# 'print(numbers[0] > numbers[1])': В этой строке кода сравниваются два целых числа из объекта 'numbers'.
# Если первое число ('numbers[0]') больше второго ('numbers[1]'), то на экран выводится 'True', иначе - 'False'.

# Как мне кажется, 'map' и 'split' используются здесь для преобразования введенной строки в числа.
# Однако, объект эnumbersэ является итератором, а не списком, и поэтому для получения элементов из него
# используется индексация '[0]' и '[1]'.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Условный оператор ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Напишите программу, где я ввожу логин и пароль.
# И если данные были введены верно, то мы выводим Authentication completed, иначе Invalid login or password.
# (Логин должен быть user, пароль - qwerty)

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
# Ввод логина и пароля от пользователя
login = input("Введите логин: ")
password = input("Введите пароль: ")
# Проверка логина и пароля
if login == "user" and password == "qwerty":
    print("Добро пожаловать")
else:
    print("Неверный логин или пароль")

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
# Ввод логина и пароля от пользователя
login = input("Введите логин: ")
password = input("Введите пароль: ")
# Проверка логина и пароля
if login == "user" and password == "qwerty":
    print("Добро пожаловать")
else:
    print("Неверный логин или пароль")

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓
# Ввод логина и пароля от пользователя
login = input("Введите логин: ")
password = input("Введите пароль: ")

# Проверка логина и пароля
if login == "user" and password == "qwerty":
    print("Добро пожаловать")
elif login == "admin" and password == "admin123":
    print("Добро пожаловать, Администратор!")
else:
    print("Неверный логин или пароль")

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №4. ↓
# Ввод логина и пароля от пользователя
login = input("Введите логин: ")
password = input("Введите пароль: ")
# Вывод результата с использованием тернарного оператора
print("Добро пожаловать" if login == "user" and password == "qwerty" else "Неверный логин или пароль")

# Этот код использует тернарный оператор непосредственно внутри функции print,
# чтобы определить, какое сообщение выводить.
# В данном случае, если условие 'login == "user"' and 'password == "qwerty"' истинно,
# то будет выведено '"Добро пожаловать"', иначе '"Неверный логин или пароль"'.
"Добро пожаловать" if login == "user" and password == "qwerty" else "Неверный логин или пароль"
# Это выражение является тернарным оператором и имеет следующую структуру:
x if condition else y
# В данном случае:
# 'x': "Добро пожаловать"
# 'condition': 'login == "user" and password == "qwerty"'
# 'y': "Неверный логин или пароль"
# Таким образом, если условие 'login == "user" and password == "qwerty"' истинно,
# то будет возвращено значение 'x', иначе будет возвращено значение 'y'.
# Выходит, что тернарный оператор определяет, какое сообщение вывести в зависимости от того,
# соответствуют ли введенные логин и пароль ожидаемым значениям.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# Напишите программу обмена валют, где я ввожу сумму в тенге и выбираю на какую валюту хочу перевести.
# (Курс USD – 420, EUR – 510, RUB - 5.8).

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
# Ввод суммы в тенге
amount_in_kzt = float(input("Введите сумму в тенге: "))
# Ввод выбранной валюты для обмена
print("Выберите валюту для обмена:")
print("1. USD")
print("2. EUR")
print("3. RUB")
choice = int(input("Введите номер валюты (1, 2 или 3): "))
# Установка курсов обмена
usd_rate = 20
eur_rate = 10
rub_rate = 5.1
# Вычисление суммы в выбранной валюте
if choice == 1:
    amount_in_selected_currency = amount_in_kzt / usd_rate
    selected_currency = "USD"
elif choice == 2:
    amount_in_selected_currency = amount_in_kzt / eur_rate
    selected_currency = "EUR"
elif choice == 3:
    amount_in_selected_currency = amount_in_kzt / rub_rate
    selected_currency = "RUB"
else:
    print("Ошибка: Неправильный выбор валюты.")
    amount_in_selected_currency = None
# Вывод результата
if amount_in_selected_currency is not None:
    print(f"{amount_in_kzt} KZT равно {amount_in_selected_currency:.2f} {selected_currency}")

#1.
# Ввод суммы в тенге
amount_in_kzt = float(input("Введите сумму в тенге: "))
# Здесь программа запрашивает у пользователя ввод суммы в тенге.
# Функция 'input' используется для получения строки от пользователя, и затем
# 'float' преобразует эту строку в число с плавающей точкой.

#2.
# Ввод выбранной валюты для обмена
print("Выберите валюту для обмена:")
print("1. USD")
print("2. EUR")
print("3. RUB")
choice = int(input("Введите номер валюты (1, 2 или 3): "))
# Здесь пользователь выбирает желаемую валюту для обмена.
# Выводится меню с вариантами валют (USD, EUR, RUB), и пользователь вводит соответствующий номер.
# Функция 'int' используется для преобразования введенной строки в целое число.

#3.
# Установка курсов обмена
usd_rate = 20
eur_rate = 10
rub_rate = 5.1
# Устанавливаются курсы обмена для каждой из валют.

#4.
# Вычисление суммы в выбранной валюте
if choice == 1:
    amount_in_selected_currency = amount_in_kzt / usd_rate
    selected_currency = "USD"
elif choice == 2:
    amount_in_selected_currency = amount_in_kzt / eur_rate
    selected_currency = "EUR"
elif choice == 3:
    amount_in_selected_currency = amount_in_kzt / rub_rate
    selected_currency = "RUB"
else:
    print("Ошибка: Неправильный выбор валюты.")
    amount_in_selected_currency = None
# В этом блоке кода используется условный оператор 'if-elif-else', чтобы определить,
# какую валюту выбрал пользователь. В зависимости от выбора, программа вычисляет эквивалентную сумму в выбранной валюте.

#5.
# Вывод результата
if amount_in_selected_currency is not None:
    print(f"{amount_in_kzt} KZT равно {amount_in_selected_currency:.2f} {selected_currency}")
#И так:
if amount_in_selected_currency is not None:
# Здесь используется условный оператор 'if', чтобы проверить, было ли успешно определено значение
# 'amount_in_selected_currency' (т.е., был ли выбор валюты корректным).

# 'amount_in_selected_currency is not None': Это условие проверяет, что 'amount_in_selected_currency не равно None'.
# 'None' в Python представляет отсутствие значения.

# Если же условие истинно (т.е., если выбор валюты был корректным), то выполняется следующая часть кода:
print(f"{amount_in_kzt} KZT равно {amount_in_selected_currency:.2f} {selected_currency}")
# Здесь используется строковый литерал f-строки (formatted string literal) для более удобного форматирования вывода.
# Разберем составляющие этой строки:

# '{amount_in_kzt}': Вставляет значение переменной 'amount_in_kzt' в строку.
# KZT равно: Просто текст в строке.
# '{amount_in_selected_currency:.2f}': Вставляет значение переменной 'amount_in_selected_currency',
# форматируя его как число с плавающей точкой с двумя знаками после запятой ':.2f'.
# '{selected_currency}': Вставляет значение переменной 'selected_currency' в строку.

# Таким образом, если пользователь выбрал правильную валюту, программа выведет сообщение, указывающее,
# сколько введенных тенге 'amount_in_kzt' эквивалентно в выбранной валюте 'amount_in_selected_currency'
# с двумя знаками после запятой, а также указывается выбранная валюта 'selected_currency'.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
def exchange_currency(amount, rate):
    return amount / rate
# Установка курсов обмена
exchange_rates = {'USD': 20, 'EUR': 10, 'RUB': 5.1}
# Ввод суммы в тенге и выбор валюты
amount_in_kzt = float(input("Введите сумму в тенге: "))
currency_choice = input("Выберите валюту для обмена (USD, EUR, RUB): ").upper()
# Проверка корректности введенной валюты
if currency_choice in exchange_rates:
    selected_currency = currency_choice
    amount_in_selected_currency = exchange_currency(amount_in_kzt, exchange_rates[selected_currency])
    print(f"{amount_in_kzt} KZT равно {amount_in_selected_currency:.2f} {selected_currency}")
else:
    print("Ошибка: Неправильная валюта.")

#1.
# Определение функции для обмена валюты
def exchange_currency(amount, rate):
    return amount / rate
#В этой части определена функция 'exchange_currency',
# которая принимает два аргумента: 'amount' (сумма в тенге) и 'rate' (курс обмена).
# Функция возвращает результат деления суммы на курс.

#2.
# Установка курсов обмена
exchange_rates = {'USD': 20, 'EUR': 10, 'RUB': 5.1}
# Здесь создается словарь exchange_rates, в котором каждой валюте (USD, EUR, RUB) соответствует ее курс обмена.

#3.
# Ввод суммы в тенге и выбор валюты
amount_in_kzt = float(input("Введите сумму в тенге: "))
currency_choice = input("Выберите валюту для обмена (USD, EUR, RUB): ").upper()
# Пользователь вводит сумму в тенге и выбирает валюту для обмена.
# 'float(input(...))' используется для ввода суммы с плавающей точкой, и '.upper()'
# преобразует введенную валюту в верхний регистр для удобства сравнения.

#4.
# Проверка корректности введенной валюты
if currency_choice in exchange_rates:
    selected_currency = currency_choice
    amount_in_selected_currency = exchange_currency(amount_in_kzt, exchange_rates[selected_currency])
    print(f"{amount_in_kzt} KZT равно {amount_in_selected_currency:.2f} {selected_currency}")
else:
    print("Ошибка: Неправильная валюта.")
# Здесь проверяется корректность введенной валюты.
# Если выбранная валюта есть в словаре 'exchange_rates', программа продолжает выполнение.
# В противном случае выводится сообщение об ошибке.

# Если введенная валюта корректна, программа сохраняет выбранную валюту в переменной 'selected_currency',
# вызывает функцию 'exchange_currency' для вычисления суммы в выбранной валюте,
# и выводит результат с двумя знаками после запятой.


# Этот вариант кода структурирован с использованием функций,
# что делает его более модульным и понятным.
# Функция 'exchange_currency' является отдельным блоком кода,
# который можно повторно использовать в других частях программы при необходимости.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓
def exchange_currency(amount, rate):
    return amount / rate

# Установка курсов обмена
exchange_rates = {'USD': 20, 'EUR': 10, 'RUB': 5.1}

# Ввод суммы в тенге
amount_in_kzt = float(input("Insert amount in KZT: "))

# Вывод меню выбора валюты и ввод выбранной валюты
print("Choose currency:")
print("[1] USD")
print("[2] EUR")
print("[3] RUB")
choice = int(input("Enter the number of the currency (1, 2, or 3): "))

# Проверка корректности выбора валюты
if 1 <= choice <= 3:
    selected_currency = list(exchange_rates.keys())[choice - 1]
    amount_in_selected_currency = exchange_currency(amount_in_kzt, exchange_rates[selected_currency])
    print(f"{amount_in_kzt} KZT is equal to {amount_in_selected_currency:.2f} {selected_currency}")
else:
    print("Invalid choice. Please select a valid currency.")

#1. Определение функции для обмена валюты:
def exchange_currency(amount, rate):
    return amount / rate
# Эта функция exchange_currency принимает два аргумента: amount (сумма в тенге) и rate (курс обмена).
# Возвращает результат деления суммы на курс.

#2. Установка курсов обмена валюты:
exchange_rates = {'USD': 420, 'EUR': 510, 'RUB': 5.8}
# Создается словарь exchange_rates, в котором каждой валюте (USD, EUR, RUB) соответствует ее курс обмена.

#3. Ввод суммы в тенге:
amount_in_kzt = float(input("Insert amount in KZT: "))
# Здесь программа запрашивает у пользователя ввести сумму в тенге.
# А 'float(input(...))' используется для ввода суммы с плавающей точкой.

#4. Вывод меню выбора валюты и ввод выбранной валюты:
print("Choose currency:")
print("[1] USD")
print("[2] EUR")
print("[3] RUB")
choice = int(input("Enter the number of the currency (1, 2, or 3): "))
# Здесь выводится меню выбора валюты, и пользователь вводит номер выбранной валюты.
# 'int(input(...))' используется для ввода целочисленного значения.

#5. Проверка корректности выбора валюты:
if 1 <= choice <= 3:
    selected_currency = list(exchange_rates.keys())[choice - 1]
    amount_in_selected_currency = exchange_currency(amount_in_kzt, exchange_rates[selected_currency])
    print(f"{amount_in_kzt} KZT is equal to {amount_in_selected_currency:.2f} {selected_currency}")
else:
    print("Invalid choice. Please select a valid currency.")
# Проверяем, что введенное пользователем значение находится в диапазоне от 1 до 3.
# Если выбор корректен, программа продолжает выполнение.

# 'list(exchange_rates.keys())': Преобразует ключи словаря exchange_rates (валюты) в список.
# '[choice - 1]': Индексирует этот список по номеру выбранной валюты
# (вычитаем 1, так как в Python индексация начинается с 0).
# 'selected_currency': Содержит строковое значение выбранной валюты.
# Вычисляется сумма в выбранной валюте с использованием функции 'exchange_currency' и выводится результат
# с двумя знаками после запятой. Если введенное значение вне диапазона от 1 до 3, программа выводит сообщение об ошибке.


   # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Блоки в PYTHON ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Вася получил первую зарплату и захотел это отпраздновать:
# провести вечер за любимым сериалом и пиццей. Хватит ли Васе денег, если подписка на онлайн кинотеатр стоит s рублей,
# пицца – p рублей, а всего он заработал m рублей?

# На вход подается стоимость подписки на онлайн-кинотеатр (s), стоимость пиццы (p) и зарплата Пети (m),
# а выводится «Да», если он сможет позволить себе покупку, а иначе – «Нет».

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
# Ввод стоимости подписки на онлайн-кинотеатр, стоимости пиццы и зарплаты Пети
subscription_cost = int(input("Введите стоимость подписки на онлайн-кинотеатр: "))
pizza_cost = int(input("Введите стоимость пиццы: "))
salary = int(input("Введите зарплату Пети: "))

# Вычисление общей суммы затрат
total_expenses = subscription_cost + pizza_cost

# Проверка, хватит ли Васе денег
if salary >= total_expenses:
    print("Да")
else:
    print("Нет")

# Этот код сначала запрашивает у пользователя стоимость подписки на кинотеатр, стоимость пиццы и зарплату.
# Затем вычисляет общую сумму затрат и сравнивает ее с зарплатой. В результате программа выводит "Да",
# если денег хватит, и "Нет" в противном случае.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
# Ввод стоимости подписки на онлайн-кинотеатр, стоимости пиццы и зарплаты Пети
subscription_cost, pizza_cost, salary = map(int, input("Введите стоимость подписки на онлайн-кинотеатр,"
                                                       " стоимость пиццы и зарплату Пети через пробел: ").split())
# Проверка, хватит ли Васе денег
if salary >= subscription_cost + pizza_cost:
    print("Да")
else:
    print("Нет")

# В этом варианте используется функция map, чтобы преобразовать введенные значения в целочисленные переменные.
# Затем сумма затрат проверяется на соответствие зарплате, и выводится соответствующий результат.




 # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Условия в PYTHON ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Условия: if, else, elif. Блоки, отступы  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# Задание №1.

# Дано: ↓

# Паша очень любит кататься на общественном транспорте, а получая билет, сразу проверяет,
# счастливый ли ему попался. Билет считается счастливым, если сумма первых трех цифр совпадает с суммой последних
# трех цифр номера билета.

# Однако Паша очень плохо считает в уме, поэтому попросил вас написать программу,
# которая проверит равенство сумм и выведет "Счастливый", если суммы совпадают, и "Обычный", если суммы различны.

#На вход программе подаётся строка из шести цифр.
# Выводить нужно только слово "Счастливый" или "Обычный", с большой буквы.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
# Ввод строки из шести цифр
ticket_number = input("Введите номер билета (шестизначное число): ")

# Проверка счастливого билета
if (int(ticket_number[0]) + int(ticket_number[1]) + int(ticket_number[2]) == int(ticket_number[3]) +
        int(ticket_number[4]) + int(ticket_number[5])):
    print("Счастливый")
else:
    print("Обычный")

#1. # Ввод строки из шести цифр
ticket_number = input("Введите номер билета (шестизначное число): ")
# Здесь программа запрашивает у пользователя ввести номер билета.
# 'input()' используется для чтения ввода пользователя.
# Введенная строка будет представлять собой шестизначное число, например, "88872514862021456695888".

#2. # Проверка счастливого билета
if (int(ticket_number[0]) + int(ticket_number[1]) + int(ticket_number[2]) == int(ticket_number[3]) +
        int(ticket_number[4]) + int(ticket_number[5])):
    print("Счастливый")
else:
    print("Обычный")
# Здесь происходит проверка на счастливый билет.
# Строка 'ticket_number' представляет собой шестизначное число, и каждый символ строки преобразуется в
# целое число с помощью 'int()'.
# Затем производится сравнение суммы первых трех цифр и суммы последних трех цифр.
# Если суммы совпадают, то выводится "Счастливый", в противном случае - "Обычный".

# Ну вот пример "с потолка взял":

# Если пользователь ввел "090234", то программа сложит 0 + 9 + 0 и 2 + 3 + 4, и увидит,
# что суммы равны, поэтому выведет "Счастливый".

# Если пользователь ввел "123456", то суммы различны, и программа выведет "Обычный".
# Таким образом, программа определяет, является ли введенный номер билета счастливым или нет.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
# Ввод строки из шести цифр
ticket_number = input("Введите номер билета (шестизначное число): ")
# Преобразование каждой цифры строки в список чисел
digits = [int(digit) for digit in ticket_number]
# Проверка счастливого билета
if sum(digits[:3]) == sum(digits[3:]):
    print("Счастливый")
else:
    print("Обычный")


#1. # Ввод строки из шести цифр
ticket_number = input("Введите номер билета (шестизначное число): ")
# Эта строка кода запрашивает у пользователя ввести номер билета.
# Введенная строка будет использоваться для проверки, является ли билет счастливым.
# Это понятно.

#2. # Преобразование каждой цифры строки в список чисел
digits = [int(digit) for digit in ticket_number]
# Эта строка создает список 'digits', который содержит каждую цифру номера билета в виде целых чисел.
# Это достигается с использованием генератора списка и функции 'int(digit)',
# которая преобразует каждый символ строки в целое число.

#3. # Проверка счастливого билета
if sum(digits[:3]) == sum(digits[3:]):
    print("Счастливый")
else:
    print("Обычный")
# Эта часть кода использует срезы списка 'digits'. 'digits[:3]' представляет собой первые три цифры номера билета,
# а 'digits[3:]' - последние три цифры.
# С помощью функции 'sum' суммируются значения каждого среза, и затем сравниваются.
# Если суммы совпадают, то выводится "Счастливый", иначе - "Обычный".

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓
# Ввод строки из шести цифр
ticket_number = input("Введите номер билета (шестизначное число): ")
# Проверка счастливого билета
result = "Счастливый" if sum(map(int, ticket_number[:3])) == sum(map(int, ticket_number[3:])) else "Обычный"
print(result)

#1. # Ввод строки из шести цифр
ticket_number = input("Введите номер билета (шестизначное число): ")
# Думаю, что тут все понятно.

#2. # Проверка счастливого билета
result = "Счастливый" if sum(map(int, ticket_number[:3])) == sum(map(int, ticket_number[3:])) else "Обычный"
print(result)
# А вот тут уже интересно. Здесь используется тернарный оператор,
# который представляет собой сжатую форму условного выражения. Давайте разберем, что происходит:

# 'map(int, ticket_number[:3])': Этот вызов map преобразует первые три символа строки 'ticket_number' в целые числа.
# 'int' используется для преобразования каждого символа в число.
# Результат представляет собой список из трех целых чисел, соответствующих первой половине номера билета.

# 'sum(map(int, ticket_number[:3]))': Этот вызов 'sum' суммирует значения в полученном списке,
# то есть сумму первой половины номера билета.

# То же самое выполняется и для второй половины номера билета '(ticket_number[3:])'.

# После этого тернарный оператор сравнивает суммы первой и второй половин номера билета.
# Если они равны, то переменной 'result' присваивается значение "Счастливый", или "Обычный".







