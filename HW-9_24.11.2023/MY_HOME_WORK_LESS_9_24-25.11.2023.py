# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Дата: 24-25 ноября 2023

# Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
# Дисциплина: Основы программирования на Python

# Урок №9 - от 24.11.2023 - Домашняя работа № 8 №8: Сортировка, поиск, регулярные выражения

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# При выполнении !!! НАВЕРНОЕ НЕ - практической работы, а домашней работы, основной алгоритм решения задачи должен
# быть описан в виде функции, получающей в качестве параметра список (а также, возможно, и дополнительные параметры).
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Дан список целых чисел. Отсортируйте его в порядке не убывания значений. Выведите полученный список на экран.

# Решите эту задачу при помощи алгоритма сортировки вставкой. Решение оформите в виде функции InsertionSort(A).

# В этой задаче нельзя пользоваться дополнительным списком и операциями удаления и вставки элементов.

# В алгоритме сортировки вставкой в каждый произвольный момент начальная часть списка уже отсортирована.

# В решении имеется цикл for i in range(1, len(A)), внутри которого в предположении, что элементы
# списка A[0], A[1], ..., A[i-1] уже отсортированы, элемент A[i] добавляется в отсортированную часть списка.

# Для этого находится позиция, в которую необходимо вставить элемент A[i],
# затем осуществляется циклический сдвиг фрагмента уже отсортированной части.

#           Input:
# 1 4 2 3 4
#           Output:
# 1 2 3 4 4


# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1.

def InsertionSort(A):
    # Проходим по всем элементам, начиная со второго
    for i in range(1, len(A)):
        key = A[i]  # Текущий элемент, который нужно вставить в отсортированную часть
        j = i - 1    # Индекс предыдущего элемента

        # Пока не достигнут начало списка и предыдущий элемент больше key
        while j >= 0 and key < A[j]:
            A[j + 1] = A[j]  # Сдвигаем элементы вправо
            j -= 1

        A[j + 1] = key  # Вставляем key в правильную позицию в отсортированной части

# Пример использования
input_list = [1, 4, 2, 3, 4]
InsertionSort(input_list)

# Вывод отсортированного списка
print(" ".join(map(str, input_list)))

# Шаг №1. - Определение функции:
def InsertionSort(A):
# Здесь определена функция InsertionSort, принимающая на вход список A,
# который мы будем сортировать в порядке не убывания.

# Шаг №2. - Проход по всем элементам списка:
for i in range(1, len(A)):
# Этот цикл for пройдется по всем элементам списка, начиная со второго (по индексу 1).
# Внутри цикла мы будем вставлять текущий элемент в отсортированную часть списка.

# Шаг №3. - Инициализация переменных:
key = A[i]  # Текущий элемент, который нужно вставить в отсортированную часть
j = i - 1  # Индекс предыдущего элемента
# Здесь мы инициализируем переменные key значением текущего элемента (элемента, который нужно вставить), и j - индексом
# предыдущего элемента.

# Шаг №4. - Цикл сдвига элементов вправо:
while j >= 0 and key < A[j]:
    A[j + 1] = A[j]  # Сдвигаем элементы вправо
    j -= 1
# В этом цикле while мы сдвигаем элементы вправо, пока не достигнем начала списка или пока предыдущий
# элемент больше key. Этот сдвиг создает место для вставки key в отсортированную часть.

# Шаг №5. - Вставляем key в правильную позицию в отсортированной части:
A[j + 1] = key
# После завершения цикла while, мы вставляем key на правильное место в отсортированной части списка.

# Шаг №6. - Пример использования:
input_list = [1, 4, 2, 3, 4]
InsertionSort(input_list)
# Мы передаем список [1, 4, 2, 3, 4] функции InsertionSort для сортировки.

# Шаг №7. - Вывод отсортированного списка:
print(" ".join(map(str, input_list)))
# Здесь мы используем print для вывода отсортированного списка. map(str, input_list) преобразует каждый элемент
# списка в строку, и затем join объединяет эти строки в одну строку, разделенную пробелами.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2.

def SelectionSort(A):
    n = len(A)
    for i in range(n):
        # Находим индекс минимального элемента в оставшейся части списка
        min_index = i
        for j in range(i + 1, n):
            if A[j] < A[min_index]:
                min_index = j
        # Обмениваем минимальный элемент с текущим элементом
        A[i], A[min_index] = A[min_index], A[i]
# Пример использования
input_list = [1, 4, 2, 3, 4]
SelectionSort(input_list)
# Вывод отсортированного списка
print(" ".join(map(str, input_list)))

# Шаг №1. - Определение функции:
def SelectionSort(A):
# В этой строке кода определена функция SelectionSort, которая принимает на вход список A.
# Эта функция будет сортировать переданный список с использованием алгоритма сортировки выбором.

# Шаг №2. - Инициализация переменных:
n = len(A)
# Здесь создается переменная n, которая содержит длину списка A.

# Шаг №3. - Цикл сортировки:
for i in range(n):
# Этот цикл for будет пройден для каждого элемента списка.

# Шаг №4. - Поиск минимального элемента:
min_index = i
for j in range(i + 1, n):
    if A[j] < A[min_index]:
        min_index = j
# В этом вложенном цикле for мы ищем минимальный элемент в оставшейся части списка.
# Если находим элемент, который меньше текущего минимального, обновляем min_index.

# Шаг №5. - Обмен минимального элемента с текущим:
A[i], A[min_index] = A[min_index], A[i]
# После завершения внутреннего цикла, мы обмениваем минимальный элемент с текущим элементом списка.

# Шаг №6. - Пример использования:
input_list = [1, 4, 2, 3, 4]
SelectionSort(input_list)
# Передаем список [1, 4, 2, 3, 4] функции SelectionSort для сортировки.

# Шаг №7. - Вывод отсортированного списка:
print(" ".join(map(str, input_list)))
# Используем print для вывода отсортированного списка. map(str, input_list)
# преобразует каждый элемент списка в строку, и затем join объединяет эти строки в одну строку, разделенную пробелами.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# Дан список целых чисел. Выведите все элементы этого списка в порядке не возрастания значений.
# Выведите новый список на экран.

# Решите эту задачу при помощи алгоритма сортировки выбором.
# Решение оформите в виде функции SelectionSort(A).

# В алгоритме сортировки выбором мы находим наибольший элемент в списке и ставим его на первое место,
# затем находим наибольший элемент из оставшихся и ставим его на второе место и т.д.

# В этой задаче разрешается модифицировать исходный список, в частности, удалить из списка i-й элемент можно
# при помощи метода pop(i), и использовать новый список для добавления в него элементов.

# Input:
# 1 4 2 3 4
# Output:
# 4 4 3 2 1


# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1.

def SelectionSort(A):
    n = len(A)
    for i in range(n):
        # Находим индекс максимального элемента в оставшейся части списка
        max_index = i
        for j in range(i + 1, n):
            if A[j] > A[max_index]:
                max_index = j
        # Обмениваем максимальный элемент с текущим элементом
        A[i], A[max_index] = A[max_index], A[i]
# Пример использования
input_list = [1, 4, 2, 3, 4]
SelectionSort(input_list)
# Вывод отсортированного списка
print(" ".join(map(str, input_list)))

# Шаг №1. - Определение функции:
def SelectionSort(A):
# В этой строке кода определена функция SelectionSort, которая принимает на вход список A.
# Эта функция будет сортировать переданный список с использованием алгоритма сортировки выбором.

# Шаг №2. - Инициализация переменных:
n = len(A)
# Создается переменная n, которая содержит длину списка A.

# Шаг №3. - Цикл сортировки:
for i in range(n):
# Данный цикл for будет пройден для каждого элемента списка.

# Шаг №4. - Поиск максимального элемента:
max_index = i
for j in range(i + 1, n):
    if A[j] > A[max_index]:
        max_index = j
# В этом вложенном цикле for мы ищем максимальный элемент в оставшейся части списка.
# Если находим элемент, который больше текущего максимального, обновляем max_index.

# Шаг №5. - Обмен максимального элемента с текущим:
A[i], A[max_index] = A[max_index], A[i]
# После завершения внутреннего цикла, мы обмениваем максимальный элемент с текущим элементом списка.

# Шаг №6. - Пример использования:
input_list = [1, 4, 2, 3, 4]
SelectionSort(input_list)
# Мы передаем список [1, 4, 2, 3, 4] функции SelectionSort для сортировки.

# Шаг №7. - Вывод отсортированного списка:
print(" ".join(map(str, input_list)))
# Здесь мы используем print для вывода отсортированного списка. map(str, input_list) преобразует каждый элемент списка
# в строку, и затем join объединяет эти строки в одну строку, разделенную пробелами.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2.

def BubbleSort(A):
    n = len(A)
    for i in range(n):
        for j in range(0, n - i - 1):
            if A[j] < A[j + 1]:
                # Обмен значениями
                A[j], A[j + 1] = A[j + 1], A[j]
# Пример использования
input_list = [1, 4, 2, 3, 4]
BubbleSort(input_list)
# Вывод отсортированного списка
print(" ".join(map(str, input_list)))

# Шаг №1. - Определение функции:
def BubbleSort(A):
# В этой строке кода определена функция BubbleSort, которая принимает на вход список A.
# Эта функция будет сортировать переданный список с использованием алгоритма сортировки пузырьком.

# Шаг №2. - Цикл сортировки:
for i in range(n):
    for j in range(0, n - i - 1):
        if A[j] < A[j + 1]:
            # Обмен значениями
            A[j], A[j + 1] = A[j + 1], A[j]
# Вложенные циклы for используются для прохода по списку и сравнения соседних элементов.
# Если элементы находятся в неправильном порядке, они обмениваются местами.

# Шаг №3. - Пример использования:
input_list = [1, 4, 2, 3, 4]
BubbleSort(input_list)
# Мы передаем список [1, 4, 2, 3, 4] функции BubbleSort для сортировки.

# Шаг №4. - Вывод отсортированного списка:
print(" ".join(map(str, input_list)))
# Здесь мы используем print для вывода отсортированного списка. map(str, input_list) преобразует каждый элемент
# списка в строку, и затем join объединяет эти строки в одну строку, разделенную пробелами.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Сортировка
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# При выполнении - домашней (практической) работы,
# основной алгоритм решения задачи должен быть описан в виде функции, получающей в качестве параметра список
# (а также, возможно, и дополнительные параметры).
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# В супермаркете проводится беспрецедентная акция – «Покупая два любых товара, третий получаешь бесплатно*»,
# а внизу мелким шрифтом приписано «* - из трех выбранных вами товаров оплачиваются два наиболее дорогих».

# Вася, идя в супермаркет, определился, какие товары он хочет купить, и узнал, сколько они стоят.
# Помогите ему определить минимальную сумму денег, которую ему нужно взять с собой,
# чтобы в итоге стать счастливым обладателем этих товаров.

# Программа получает на вход число N (1 ≤ N ≤ 1000), а затем N чисел – стоимости выбранных Васей товаров.

# Все стоимости – натуральные числа, не превышающие 10000.

# Выведите одно число – сумму денег, которую Вася должен взять с собой в супермаркет (минимально возможную).

#           Input:
# 6
# 1   5   4   3   5   7
#           Output:
# 19


# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1.

def calculate_minimum_cost(N, costs):
    # Сортируем стоимости товаров по убыванию
    sorted_costs = sorted(costs, reverse=True)
    total_cost = 0
    for i in range(0, N, 3):
        total_cost += sum(sorted_costs[i:i+2])
    return total_cost
# Пример использования
N = 6
costs = [1, 5, 4, 3, 5, 7]
result = calculate_minimum_cost(N, costs)
print(result)

# Шаг №1. - Определение функции:
def calculate_minimum_cost(N, costs):
# Здесь определена функция calculate_minimum_cost, которая принимает два параметра:
# N - число товаров и costs - список стоимостей товаров.

# Шаг №2. - Сортировка стоимостей:
sorted_costs = sorted(costs, reverse=True)
# Мы создаем новый список sorted_costs, в котором стоимости товаров отсортированы по убыванию.

# Шаг №3. - Инициализация общей стоимости:
total_cost = 0
# Создается переменная total_cost, которая будет хранить общую минимальную стоимость, которую нужно заплатить Васе.

# Шаг №4. - Цикл по товарам:
for i in range(0, N, 3):
# Мы итерируем по индексам товаров с шагом 3 (так как каждый третий товар бесплатный).

# Шаг №5. - Суммирование стоимости товаров:
total_cost += sum(sorted_costs[i:i + 2])
# В каждой итерации мы добавляем к total_cost сумму двух наименьших товаров из текущего тройного
# блока (так как третий товар бесплатный).

# Шаг №6. - Возврат результата:
return total_cost
# Функция возвращает общую минимальную стоимость.

# Шаг №7. - Пример использования:
N = 6
costs = [1, 5, 4, 3, 5, 7]
result = calculate_minimum_cost(N, costs)
print(result)
# Мы передаем в функцию число товаров N=6 и список стоимостей товаров costs=[1, 5, 4, 3, 5, 7].
# Функция возвращает минимальную стоимость, и мы выводим результат на экран.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2.
def calculate_minimum_cost(N, costs):
    # Сортируем стоимости товаров по убыванию
    sorted_costs = sorted(costs, reverse=True)

    # Инициализируем общую стоимость
    total_cost = 0

    # Индекс для прохода по отсортированным стоимостям
    i = 0

    # Проходим по списку стоимостей
    while i < N:
        # Оплачиваем два наиболее дорогих товара
        total_cost += sorted_costs[i] + sorted_costs[i + 1]
        # Переходим к следующей группе товаров
        i += 3

    return total_cost


# Пример использования
N = 6
costs = [1, 5, 4, 3, 5, 7]
result = calculate_minimum_cost(N, costs)
print(result)

# Шаг №1 - Инициализация переменных:
# N = 6 - количество товаров.
# costs = [1, 5, 4, 3, 5, 7] - стоимости товаров.

# Шаг №2 - Сортировка стоимостей по убыванию:
# sorted_costs = sorted(costs, reverse=True) - теперь sorted_costs равен [7, 5, 5, 4, 3, 1].

# Шаг №3 - Инициализация переменной для общей стоимости:
# total_cost = 0.

# Шаг №4 - Цикл обработки стоимостей товаров:
# i = 0 - индекс для прохода по отсортированным стоимостям.

# 1-я итерация:
# total_cost += sorted_costs[0] + sorted_costs[1] - добавляем два наиболее дорогих товара (7 и 5) к общей стоимости.
# i += 3 - переходим к следующей группе товаров.

# 2-я итерация:
# total_cost += sorted_costs[3] + sorted_costs[4] - добавляем два наиболее дорогих товара (4 и 3) к общей стоимости.
# i += 3 - переходим к следующей группе товаров.

# Шаг №5 - Завершение выполнения цикла:
# Так как i выходит за пределы списка, цикл завершается.

# Шаг №6 - Вывод результата:
# print(result) - выводим общую минимальную стоимость, которая равна 19.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# Задание №2.

# Дано: ↓

# Дан список чисел (содержащий не менее двух элементов).
# Найдите в нем два ближайших друг к другу числа (то есть два числа с наименьшей разностью).

# Выведите эти числа в порядке не убывания.
# Используйте встроенную сортировку языка Python.
# Решение должно иметь сложность встроенной сортировки + O(n).
# Input
# 9 4 1 6
# Output:
# 4 6

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1.

def find_closest_numbers(lst):
    # Сортируем список
    sorted_lst = sorted(lst)
    # Инициализируем переменные для хранения двух ближайших чисел и их разности
    min_difference = float('inf')
    closest_pair = ()
    # Проходим по отсортированному списку и находим ближайшие числа
    for i in range(len(sorted_lst) - 1):
        difference = sorted_lst[i + 1] - sorted_lst[i]
        if difference < min_difference:
            min_difference = difference
            closest_pair = (sorted_lst[i], sorted_lst[i + 1])
    return closest_pair
# Пример использования
input_numbers = [9, 4, 1, 6]
result = find_closest_numbers(input_numbers)
print(*result)

# Шаг №1. - Создание функции:
def find_closest_numbers(lst):
# Начнем с создания функции find_closest_numbers, которая принимает список чисел в качестве аргумента.

# Шаг №2. - Сортировка списка:
sorted_lst = sorted(lst)
# Внутри функции мы сначала создаем отсортированный список из входного списка.
# Теперь sorted_lst содержит те же числа, что и lst, но в отсортированном порядке.

# Шаг №3. - Нахождение ближайших чисел:
min_difference = float('inf')
closest_pair = ()
# Затем мы инициализируем переменные min_difference и closest_pair. min_difference будет использоваться для
# отслеживания минимальной разницы между числами, а closest_pair - для хранения пары ближайших чисел.

# Шаг №4. - Проход по списку:
for i in range(len(sorted_lst) - 1):
    difference = sorted_lst[i + 1] - sorted_lst[i]
    if difference < min_difference:
        min_difference = difference
        closest_pair = (sorted_lst[i], sorted_lst[i + 1])
# Мы используем цикл for, чтобы пройти по отсортированному списку и вычислить разницу между соседними числами.
# Если эта разница меньше текущей минимальной разницы, мы обновляем значения min_difference и closest_pair.

# Шаг №5. - Возвращение результата:
return closest_pair
# Наконец, возвращаем пару ближайших чисел в порядке неубывания.

# Шаг №6. - Пример использования:
input_numbers = [9, 4, 1, 6]
result = find_closest_numbers(input_numbers)
print(*result)
# Вне функции, мы создаем список чисел и вызываем функцию find_closest_numbers, а затем выводим результат.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2.

def find_closest_numbers(lst):
    # Сортируем список
    sorted_lst = sorted(lst)
    # Используем zip для создания пар соседних элементов
    pairs = zip(sorted_lst, sorted_lst[1:])
    # Находим пару с минимальной разностью
    closest_pair = min(pairs, key=lambda pair: pair[1] - pair[0])
    return closest_pair
# Пример использования
input_numbers = [9, 4, 1, 6]
result = find_closest_numbers(input_numbers)
print(*result)

# Шаг №1. - Создание функции:
def find_closest_numbers(lst):
# Начнем с создания функции find_closest_numbers, которая принимает список чисел в качестве аргумента.

# Шаг №2. - Сортировка списка:
sorted_lst = sorted(lst)
# Внутри функции мы сначала создаем отсортированный список из входного списка.

# Шаг №3. - Использование zip для создания пар соседних элементов:
pairs = zip(sorted_lst, sorted_lst[1:])
# Мы используем функцию zip для создания пар соседних элементов в отсортированном списке.
# Теперь pairs - это объект zip, содержащий пары соседних элементов.

# Шаг №4. - Нахождение ближайших чисел с использованием функции min:
closest_pair = min(pairs, key=lambda pair: pair[1] - pair[0])
# Мы используем функцию min, чтобы найти пару с минимальной разностью между соседними элементами.
# Ключевая функция lambda pair: pair[1] - pair[0] возвращает разность между вторым и первым элементами пары.

# Шаг №5. - Возвращение результата:
return closest_pair
# Наконец, возвращаем пару ближайших чисел.

# Шаг №6. - Пример использования:
input_numbers = [9, 4, 1, 6]
result = find_closest_numbers(input_numbers)
print(*result)
# Вне функции, мы создаем список чисел и вызываем функцию find_closest_numbers, а затем выводим результат.







