# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Дата: 22-23 ноября 2023

# Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
# Дисциплина: Основы программирования на Python

# Урок №9 - от 24.11.2023 - Практическая работа № 8 Практическая работа №8: Сортировка, поиск, регулярные выражения

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# При выполнении практической работы,
# основной алгоритм решения задачи должен быть описан в виде функции,
# получающей в качестве параметра список (а также, возможно, и дополнительные параметры).
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Дан список. Определите, является ли он монотонно возрастающим (то есть верно ли, что каждый элемент
# этого списка больше предыдущего).
# Выведите YES, если список монотонно возрастает и NO в противном случае.
# Решение оформите в виде функции IsAscending(A).
# Input:
# 1 7 9
# Output:
# Yes

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

def IsAscending(A):
    for i in range(1, len(A)):
        if A[i] <= A[i-1]:
            return "No"
    return "Yes"
# Пример использования
input_list = [1, 7, 9]
result = IsAscending(input_list)
print(result)

# Шаг №1. - Создание функции:
def IsAscending(A):
# Создаем функцию с именем IsAscending, которая принимает один аргумент A, который должен быть списком.

# Шаг №2. - Цикл для проверки:
for i in range(1, len(A)):
# Используем цикл for, который начинается с индекса 1 и проходит по всем элементам списка A.

# Шаг №3. - Проверка монотонного возрастания:
    if A[i] <= A[i-1]:
# Здесь мы сравниваем текущий элемент A[i] с предыдущим элементом A[i-1].
# Если текущий элемент меньше или равен предыдущему, это нарушает монотонное возрастание.

# Шаг №4. - Возврат результата:
return "No"
# Если условие в пункте 3 выполняется, функция сразу возвращает "No", что означает, что список не монотонно возрастает.

# Шаг №5. - Возврат "Yes" в противном случае:
return "Yes"
# Если весь цикл завершается без нарушения монотонного возрастания, функция возвращает "Yes", указывая на то,
# что список монотонно возрастает.

# Шаг №6. - Пример использования функции:
input_list = [1, 7, 9]
result = IsAscending(input_list)
print(result)
# В данном случае, функция вызывается с аргументом input_list, и результат (строка "Yes" или "No") выводится на экран.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓

def IsAscending(A):
    return all(A[i] <= A[i+1] for i in range(len(A)-1))
# Пример использования
input_list = [1, 7, 9]
result = "Yes" if IsAscending(input_list) else "No"
print(result)

# Шаг №1. - Создание функции:
def IsAscending(A):
# Это начальная строка для определения функции IsAscending, которая принимает список A в качестве аргумента.

# Шаг №2. - Использование all() и генератора списка:
    return all(A[i] <= A[i+1] for i in range(len(A)-1))
# Используем встроенную функцию all(), которая принимает итерируемый объект (в данном случае,
# генератор списка) и возвращает True, если все элементы этого объекта истинны.
# Генератор списка создает последовательность значений True или False для каждой пары соседних элементов списка.

# Шаг №3. - Итерация по списку:
for i in range(len(A) - 1)
# Используем цикл for, который проходит по индексам от 0 до len(A)-2 (последний элемент списка не сравнивается
# с последующим).

# Шаг №4. - Проверка монотонного возрастания:
A[i] <= A[i + 1]
# Каждая итерация цикла сравнивает текущий элемент A[i] с следующим элементом A[i+1].
# Если хотя бы одно из этих сравнение ложно, генератор создает False.

# Шаг №5. - Возврат результата:
# Если все сравнения истинны для всех пар соседних элементов, то all() вернет True, и функция вернет True,
# что означает, что список монотонно возрастает. В противном случае, функция вернет False.

# Шаг №6. - Пример использования функции:
input_list = [1, 7, 9]
result = "Yes" if IsAscending(input_list) else "No"
print(result)
# В данном случае, функция вызывается с аргументом input_list, и результат (строка "Yes" или "No") выводится на экран.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# Дан список чисел, число a и натуральное число k. Выведите индекс k-го по счету появления в массиве числа a.
# Если число a встречается в массиве менее k раз, выведите число -1.
# Решение оформите в виде функции KthAppearance(A, a, k). Input
# 1 2 1 3 2 3 2 3 2 2 3 2
# Output:
# 5
# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

def KthAppearance(A, a, k):
    count = 0  # переменная для отслеживания количества появлений числа a
    for i in range(len(A)):
        if A[i] == a:
            count += 1
            if count == k:
                return i + 1  # возвращаем индекс (индексация начинается с 1)
    return -1  # если число a встречается в массиве менее k раз

# Пример использования
input_list = [1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2]
number_to_find = 2
kth_appearance = 2
result = KthAppearance(input_list, number_to_find, kth_appearance)
print(result)

# Шаг №1. - Инициализация переменной count:
count = 0
# Эта переменная будет использоваться для отслеживания количества появлений числа a.

# Шаг №2. - Цикл по списку A:
for i in range(len(A)):
# Используем цикл for, чтобы пройти по каждому элементу списка A.

# Шаг №3. - Проверка на совпадение с числом a:
    if A[i] == a:
# Если текущий элемент списка совпадает с числом a, мы увеличиваем переменную count.

# Шаг №4. - Проверка на достижение k-го появления:
if count == k:
    return i + 1
# Если количество появлений числа a достигло k, то возвращаем индекс элемента, увеличенный на 1,
# так как индексация начинается с 1.

# Шаг №5. - Возврат -1, если число a встречается менее k раз:
return -1
# Получается, если цикл завершается, не достигнув k-го появления, возвращаем -1.

# Шаг №6. - Пример использования функции:
input_list = [1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2]
number_to_find = 2
kth_appearance = 2
result = KthAppearance(input_list, number_to_find, kth_appearance)
print(result)
# В данном примере, функция вызывается с аргументами input_list, number_to_find (число a), и kth_appearance.
# Результат (индекс k-го появления или -1) выводится на экран.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
# Попробую использовать встроенную функцию enumerate(), которая предоставляет индекс каждого элемента вместе с самим
# элементом во время итерации по списку.

def KthAppearance(A, a, k):
    count = 0  # переменная для отслеживания количества появлений числа a
    for i, num in enumerate(A, start=1):  # start=1 для индексации с 1
        if num == a:
            count += 1
            if count == k:
                return i
    return -1

# Пример использования
input_list = [1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2]
number_to_find = 2
kth_appearance = 2
result = KthAppearance(input_list, number_to_find, kth_appearance)
print(result)

# Я все расписывать пошагово в данном примере не буду, просто распишу так, Этот код работает похожим образом,
# но использует функцию enumerate(), чтобы получать и индекс, и значение элемента списка. Параметр start=1 указывает,
# что индексация начинается с 1.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Сортировка
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# При выполнении практической работы,
# основной алгоритм решения задачи должен быть описан в виде функции, получающей в качестве параметра список
# (а также, возможно, и дополнительные параметры).
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Системный администратор вспомнил, что давно не делал архива пользовательских файлов. Однако, объем диска, куда
# он может поместить архив, может быть меньше чем суммарный объем архивируемых файлов.

# Известно, какой объем занимают файлы каждого пользователя.

# Напишите программу, которая по заданной информации о пользователях и свободному объему на архивном диске определит
# максимальное число пользователей, чьи данные можно поместить в архив, при этом используя свободное
# место как можно более полно.

# Программа получает на вход в одной строке число S размер свободного места на диске, и число N — количество
# пользователей, после этого идет N чисел — объем данных каждого пользователя, записанных каждое в отдельной строке.

# Выведите наибольшее количество пользователей, чьи данные могут быть помешены в архив.

# Input:
# 100 2
# 200
# 50

# Output:
# 1

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

def max_users_to_archive(free_space, num_users, user_data):
    # Сортируем пользователей по убыванию их объема данных
    sorted_users = sorted(user_data, reverse=True)
    # Инициализируем счетчик пользователей и занятого места на диске
    users_count = 0
    used_space = 0
    # Перебираем пользователей и добавляем их на диск, пока есть свободное место
    for user in sorted_users:
        if used_space + user <= free_space:
            used_space += user
            users_count += 1
        else:
            break  # Если не хватает места, выходим из цикла
    return users_count
# Чтение входных данных
input_data = input().split()
free_space = int(input_data[0])
num_users = int(input_data[1])
user_data = [int(input()) for _ in range(num_users)]
# Вызываем функцию и выводим результат
result = max_users_to_archive(free_space, num_users, user_data)
print(result)


# Шаг №1. - Чтение входных данных:
input_data = input().split()
free_space = int(input_data[0])
num_users = int(input_data[1])
user_data = [int(input()) for _ in range(num_users)]
# В этом блоке кода мы считываем входные данные. input().split() разделяет ввод на отдельные строки, и мы преобразуем
# их в целые числа. Первое число - free_space, второе - num_users, а последующие строки - объемы данных каждого
# пользователя, которые мы собираем в списке user_data.

# Шаг №2. - Инициализация переменных:
def max_users_to_archive(free_space, num_users, user_data):
    sorted_users = sorted(user_data, reverse=True)
    users_count = 0
    used_space = 0
# В этой части кода мы создаем функцию max_users_to_archive с параметрами free_space,
# num_users, и user_data. Мы также инициализируем переменные sorted_users (отсортированный список пользователей по
# убыванию объема данных), users_count (счетчик пользователей) и used_space (количество использованного места на диске).

# Шаг №3. - Сортировка пользователей:
sorted_users = sorted(user_data, reverse=True)
# Сортируем список пользователей в порядке убывания их объема данных с помощью sorted()
# и аргумента reverse=True.

# Шаг №4. - Инициализация счетчиков:
users_count = 0
used_space = 0
# Инициализируем счетчик пользователей и количество использованного места на диске.

# Шаг №5. - Цикл по пользователям:
for user in sorted_users:
    if used_space + user <= free_space:
        used_space += user
        users_count += 1
    else:
        break
# Здесь мы итерируем по пользователям в порядке убывания объема данных. Если добавление текущего пользователя не
# приведет к превышению свободного места на диске, мы увеличиваем users_count и обновляем used_space.
# Как только не хватает места, мы выходим из цикла с помощью break.

# Шаг №6. - Вывод результата:
return users_count
# Функция возвращает количество пользователей, чьи данные могут быть помещены на диск.

# Шаг №7. - Пример использования:
result = max_users_to_archive(free_space, num_users, user_data)
print(result)
# Тут вызываем функцию с введенными значениями и выводим результат.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓

def max_users_to_archive(free_space, user_data):
    # Сортировка объемов данных пользователей в порядке возрастания
    sorted_user_data = sorted(user_data)
    users_count = 0  # Количество пользователей, чьи данные помещены в архив
    total_data_size = 0  # Общий объем данных пользователей
    for data_size in sorted_user_data:
        total_data_size += data_size
        # Проверка, превысили ли свободное место на диске
        if total_data_size <= free_space:
            users_count += 1
        else:
            break  # Прекращаем добавление пользователей, если свободное место превышено
    return users_count
# Пример использования
input_line = input("Введите свободное место и количество пользователей: ")
free_space, user_count, *user_data = map(int, input_line.split())

result = max_users_to_archive(free_space, user_data)
print(result)

# Шаг №1. - Создание функции:
def max_users_to_archive(free_space, user_data):
# Создается функция max_users_to_archive, которая принимает два аргумента: free_space (свободное место на диске)
# и user_data (список объемов данных каждого пользователя).

# Шаг №2. - Сортировка объемов данных:
    sorted_user_data = sorted(user_data)
# Объемы данных пользователей сортируются в порядке возрастания.

# Шаг №3. - Инициализация переменных:
users_count = 0
total_data_size = 0
# users_count - переменная для отслеживания количества пользователей, чьи данные помещены в архив.
# total_data_size - переменная для отслеживания общего объема данных.

# Шаг №4. - Итерация по отсортированным данным:
for data_size in sorted_user_data:
# Мы используем цикл for, чтобы пройти по каждому объему данных пользователя из отсортированного списка.

# Шаг №5. - Добавление объема данных и проверка:
total_data_size += data_size
# К общему объему данных добавляется объем текущего пользователя.
if total_data_size <= free_space:
    users_count += 1
# Проверяется, не превышает ли общий объем данных свободное место на диске. Если нет, увеличиваем users_count.
# В противном случае прерываем цикл, так как дальнейшие пользователи уже не влезут.

# Шаг №6. - Возврат результата:
    return users_count
# Функция возвращает количество пользователей, чьи данные могут быть помещены в архив.

# Шаг №7. - Пример использования функции:
input_line = input("Введите свободное место и количество пользователей: ")
free_space, user_count, *user_data = map(int, input_line.split())

result = max_users_to_archive(free_space, user_data)
print(result)
# Пример ввода свободного места и объемов данных пользователей. Функция вызывается с этими данными, и
# результат выводится на экран.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# После затянувшегося совещания директор фирмы решил заказать такси, чтобы развезти сотрудников по домам.
# Он заказал N машин —ровно столько, сколь у него сотрудников. Однако, когда они подъехали, оказалось, что у каждого
# водителя такси свой тариф за 1 километр.

# Директор знает, какому сотруднику сколько километров от работы до дома (к сожалению, все сотрудники живут в разных
# направлениях, поэтому нельзя отправить двух сотрудников на одной машине). Теперь директор хочет определить, сколько
# придется заплатить за перевозку всех сотрудников. Естественно, директор хочет заплатить как можно меньшую сумму.

# В первой строке записаны N чисел через пробел, задающих расстояния в километрах от работы до домов сотрудников
# компании. Во второй строке записаны N чисел — тарифы за проезд одного километра в такси.

# Выведите одно целое число — наименьшую сумму, которую придется заплатить за доставку всех сотрудников.

# Input:
# 10            20            30
# 50            20            30
# 50

# Output:
# 1 700

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант только №1. ↓ (так как я его делал уже на уроке)

def calculate_minimum_cost(distances_str, tariffs_str):
    distances = list(map(int, distances_str.split()))
    tariffs = list(map(int, tariffs_str.split()))

    # Сортируем расстояния по возрастанию, тарифы - по убыванию
    sorted_distances = sorted(distances)
    sorted_tariffs = sorted(tariffs, reverse=True)

    # Перемножаем отсортированные списки и суммируем результаты
    total_cost = sum(distance * tariff for distance, tariff in zip(sorted_distances, sorted_tariffs))

    return total_cost

# Пример использования
distances_input = "10 20 30"
tariffs_input = "50 20 30"

result = calculate_minimum_cost(distances_input, tariffs_input)
print(result)

# Шаг №1. - Определение функции:
def calculate_minimum_cost(distances_str, tariffs_str):
# Здесь определена функция calculate_minimum_cost с двумя параметрами: distances_str (строка с расстояниями) и
# tariffs_str (строка с тарифами).

# Шаг №2. - Преобразование строк в списки:
distances = list(map(int, distances_str.split()))
tariffs = list(map(int, tariffs_str.split()))
# В этой части кода строки с расстояниями и тарифами преобразуются в списки целых чисел с использованием map и split.
# split() разбивает строку на подстроки по пробелам, а map(int, ...) преобразует каждую подстроку в целое число.

# Шаг №3. - Сортировка расстояний и тарифов:
sorted_distances = sorted(distances)
sorted_tariffs = sorted(tariffs, reverse=True)
# Здесь расстояния сортируются по возрастанию (sorted_distances), а тарифы - по убыванию (sorted_tariffs).
# Сортировка нужна для того, чтобы при умножении расстояний на соответствующие тарифы получить минимальную стоимость.

# Шаг №4. - Перемножение списков и суммирование:
total_cost = sum(distance * tariff for distance, tariff in zip(sorted_distances, sorted_tariffs))
# В этой строке кода используется генератор списка с zip, чтобы получить пары (расстояние, тариф), а затем умножить
# их и сложить результаты с помощью sum. Это позволяет нам найти общую стоимость
# по минимальному тарифу для каждого расстояния.

# Шаг №5. - Возврат результата:
return total_cost
# Функция возвращает общую стоимость.

# Шаг №6. - Пример использования:
distances_input = "10 20 30"
tariffs_input = "50 20 30"
result = calculate_minimum_cost(distances_input, tariffs_input)
print(result)

# В этом блоке кода мы создаем строки с расстояниями и тарифами, вызываем функцию calculate_minimum_cost,
# передаем ей эти строки и выводим результат.






