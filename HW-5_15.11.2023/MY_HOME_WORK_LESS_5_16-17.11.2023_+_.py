# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Дата: 17-18 ноября 2023

# Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
# Дисциплина: Основы программирования на Python

# Домашнее задание №5.- УПРАВЛЯЮЩИЕ ВЫРАЖЕНИЯ. БЛОКИ, УСЛОВИЯ, ЦИКЛЫ

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №0.

# Дано: ↓

# В Институте биоинформатики между информатиками и биологами устраивается соревнование.
# Победителям соревнования достанется большой и вкусный пирог.
# В команде биологов a человек, а в команде информатиков — b человек.

# Нужно заранее разрезать пирог таким образом, чтобы можно было раздать кусочки пирога любой команде,
# выигравшей соревнование, при этом каждому участнику этой команды должно достаться одинаковое число кусочков пирога.
# И так как не хочется резать пирог на слишком мелкие кусочки, нужно найти минимальное подходящее число.

# Напишите программу, которая помогает найти это число.

# Программа должна считывать размеры команд (два положительных целых числа aa и b,
# каждое число вводится на отдельной строке) и выводить наименьшее число d,
# которое делится на оба этих числа без остатка.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

# Эта задача связана с нахождением наименьшего общего кратного (НОК) двух чисел.
# Для нахождения НОК можно воспользоваться формулой:

# НОК(a,b)= a⋅b/НОД(a,b)

# где НОД(a,b) - наибольший общий делитель.
# Мы можем использовать стандартную функцию для нахождения НОД,
# например, через алгоритм Евклида, и затем использовать этот результат для вычисления НОК.

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

# Ввод данных
a = int(input())
b = int(input())

# Вывод результата
print(lcm(a, b))

# Теперь, если ввести данные из примеров: 1 и 2
# Вывод будет: 2
# А для ввода: 7 и 5
# Вывод будет: 35
# Ввод далее: 15 и 15
# Вывод будет: 15


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
import math
# Ввод данных
a = int(input())
b = int(input())
# Вычисление НОК
lcm_result = a * b // math.gcd(a, b)
# Вывод результата
print(lcm_result)

#Шаг № 1: Импортируйте библиотеку math для использования функции gcd (наибольший общий делитель).
import math

# Шаг № 2: Введите размеры команд (два положительных целых числа a и b). Например, 7 и 5.
# Ввод данных
a = int(input())
b = int(input())

# Шаг № 3: Создайте функцию 'lcm', которая вычисляет наименьшее общее кратное (НОК) двух чисел, используя формулу
# a, b/НОД * (a, b)
def lcm(a, b):
    return a * b // math.gcd(a, b)

# Шаг № 4: Вызовите функцию 'lcm' с введенными значениями a и b.
lcm_result = lcm(a, b)

# Шаг № 5: Выведите результат.
# Вывод результата
print(lcm_result)

# Теперь к примеру, если ввести данные 7 и 5, программа найдет НОК этих чисел и выведет результат: 35

# Аналогично, для введенных данных 15 и 15, результат будет: 15

# Таким образом, программа шаг за шагом выполняет вычисления и выводит наименьшее общее кратное заданных чисел.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓
# Попробуем использовать использовать свойство НОК и НОД:
# Формула: НОК(a, b)*НОД(a*b)=a, b
# При условии, что если мы знаем НОД(a,b), мы можем вычислить НОК(a,b) с использованием этого свойства.
# Вот пример кода:
import math
# Ввод данных
a = int(input())
b = int(input())
# Вычисление НОД
gcd_result = math.gcd(a, b)
# Вычисление НОК
lcm_result = a * b // gcd_result
# Вывод результата
print(lcm_result)

#Подробнее:
#Шаг № 1: Импортируйте библиотеку math для использования функции gcd (наибольший общий делитель).
import math

# Шаг № 2: Введите размеры команд (два положительных целых числа a и b).
# Ввод данных
a = int(input())
b = int(input())

# Шаг № 3: Создайте переменную 'gcd_result' и присвойте ей значение НОД(a, b), используя функцию 'math.gcd'.
# Вычисление НОД
gcd_result = math.gcd(a, b)

# Шаг № 4: Создайте переменную 'lcm_result' и присвойте ей значение НОК(a*b), используя свойство НОК(a, b)НОД(a, b)=a, b.
# Вычисление НОК
lcm_result = a * b // gcd_result

# Шаг № 5: Выведите результат.
# Вывод результата
print(lcm_result)

# Теперь, снова, если ввести данные 7 и 5, программа найдет НОК этих чисел и выведет результат: 35

# И также, для введенных данных 15 и 15, результат будет: 15

# Этот код решает задачу, используя свойства НОД и НОК, что также является валидным подходом к данной задаче.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
 #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Цикл For ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~#
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# Цикл for в языке программирования Python используется для перебора элементов в последовательности
# (например, списке, кортеже, строке и т.д.). Он обеспечивает удобный способ выполнения определенных действий для
# каждого элемента в последовательности. Синтаксис цикла for выглядит следующим образом:

for переменная in последовательность:
    # блок кода, который будет выполнен для каждого элемента
    # переменная принимает значение текущего элемента на каждой итерации

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# По данному натуральном n вычислите сумму 1!+2!+3!+...+n!1!+2!+3!+...+n!.
# В решении этой задачи можно использовать только один цикл.
# Пользоваться математической библиотекой math в этой задаче запрещено.



# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
# Так как пользоваться математической библиотекой math нельзя, попробую использовать цикл for, чтобы вычислить итерации
# по значениям от 1 до n, и узнать факториал каждого числа - допустим прибавляя его к общей сумме.

    def factorial(num):
        result = 1
        for i in range(1, num + 1):
            result *= i
        return result


    def sum_of_factorials(n):
        total_sum = 0
        for j in range(1, n + 1):
            total_sum += factorial(j)
        return total_sum


    # Ввод данных
    n = int(input("Введите натуральное число n: "))

    # Вывод результата
    result = sum_of_factorials(n)
    print(result)

# Так получается, если я например введу 5 то программа должна выдать 1+2+6+24+120 - что равно 153 - как в примере.
# Но, я все-таки хочу расписать все подробно (для себя и на память для потмоков :D ;D )

# Шаг 1. - Пишем функцию 'factorial' для вычисления этого самого Факториала.
def factorial(num):
    result = 1
    for i in range(1, num + 1):
        result *= i
    return result
# Теперь получается, что эта функция принимает число 'num' и возвращает его факториал.
# Факториал числа - это произведение всех положительных целых чисел от 1 до этого числа.
# Когда Мы используем цикл 'for', Мы знаем, что она нужна для умножения чисел от 1 до 'num' включительно,
# для того чтобы получить факториал. Начальное значение 'result' установлено в 1, и каждый раз в цикле умножается
# на текущее значение 'i'.

# Шаг 2. - Теперь нам нужно вычислить суммы факториалов, для это я думаю, можно записать функцию: 'sum_of_factorials'.
def sum_of_factorials(n):
    total_sum = 0
    for j in range(1, n + 1):
        total_sum += factorial(j)
    return total_sum
# Тогда тут получается, что эта функция принимает натуральное число n и возвращает сумму факториалов от '1!' до 'n!'.
# Затем, используется цикл 'for' для итерации по значениям от 1 до 'n' включительно.
# Теперь на каждом шаге добавляется к 'total_sum' факториал текущего значения 'j', используя функцию 'factorial'.

# Шаг №3. - Когда мы записали все необходимые функции нам нужен ввод данных и вызов этих функций.
# Ввод данных
n = int(input("Введите натуральное число n: "))
# Вывод результата
result = sum_of_factorials(n)
print(result)
# Наконец, пользователь вводит натуральное число 'n'.
# Затем вызывается функция 'sum_of_factorials' с введенным значением 'n', и результат выводится на экран.

# В итоге, если все удачно, то программа сначала вычисляет факториалы от 1! до n! и затем суммирует их,
# выводя общую сумму.

# ВОЗМОЖНО ВОЗМОЖНО ВОЗМОЖНО ВОЗМОЖНО ВОЗМОЖНО ЭТО НЕ ВЕРНЫЙ ВАРИАНТ !!! (ВАРИАНТ 1)

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
# Попробую решить данную задачу иначе.

# Ввод данных
n = int(input("Введите натуральное число n: "))
# Инициализация переменных
total_sum = 0
current_factorial = 1
# Вычисление суммы факториалов
for j in range(1, n + 1):
    current_factorial *= j
    total_sum += current_factorial
# Вывод результата
print(total_sum)

# Попробую все расписать подробнее
# Шаг №1. - Ввожу данные:
n = int(input("Введите натуральное число n: "))
# Что к чему:  Здесь пользователь вводит натуральное число n с клавиатуры.
# Функция input используется для получения ввода, а int преобразует введенное значение в целое число.

# Шаг №2. - Нужно инициализировать данные:
total_sum = 0
current_factorial = 1
# Создаю две переменные: total_sum для хранения суммы факториалов и current_factorial для текущего значения факториала.

# Шаг №3. - Теперь уже тут занимаемся ВЫЧИСЛЕНИЕМ суммы ФАКТОРИАЛА в Одном цикле
for j in range(1, n + 1):
    current_factorial *= j
    total_sum += current_factorial
# Так, получается, что: здесь используется цикл 'for' для итерации по значениям от 1 до 'n' включительно.
# На каждом шаге цикла умножается текущее значение 'current_factorial' на текущее значение 'j',
# затем это произведение прибавляется к 'total_sum'.
# Таким образом, каждый элемент суммы - это факториал соответствующего числа.

# Шаг №4. - Итог
print(total_sum)
# Наконец, программа выводит на экран общую сумму факториалов, которую мы вычислили в предыдущем шаге.
# Программа выполняет задачу по вычислению суммы факториалов для введенного пользователем значения 'n' с использованием
# только одного цикла.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# По данному натуральному n ≤ 9 выведите лесенку из n ступенек, i-я ступенька состоит из чисел от 1 до i без пробелов.

# Input                                                                   Output
# 3                                                                       1
#                                                                         12
#                                                                         123
# 4                                                                       1
#                                                                         12
#                                                                         123
#                                                                         1234
# 2                                                                       1
#                                                                         12

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

# Тут как мне кажется можно использовать следущее решение.
# Для решения этой задачи мы можем использовать два вложенных цикла: один для итерации по
# числам от 1 до n (включительно) и второй для вывода чисел от 1 до текущего значения внешнего цикла.
# Ввод данных
n = int(input("Введите натуральное число n (n ≤ 9): "))
# Формирование лесенки
for i in range(1, n + 1):
    for j in range(1, i + 1):
        print(j, end='')
    print()
# Этот код создает лесенку из n ступенек, где каждая ступенька содержит числа от 1 до i.
# Каждая строка выводится с новой строки, и числа в каждой строке выводятся без пробелов.

# Далее подробнее о коде:
# Шаг №1. - Вводим данные
n = int(input("Введите натуральное число n (n ≤ 9): "))
# Пользователь вводит натуральное число 'n', которое ограничено условием задачи (n ≤ 9).
# Функция 'input' используется для получения ввода, а 'int' преобразует введенное значение в целое число.

# Шаг №2. - Здесь происходит формирование лесенки с использованием двух циклов
for i in range(1, n + 1):
    for j in range(1, i + 1):
        print(j, end='')
    print()
# Здесь используется два вложенных цикла.
# Внешний цикл 'for i in range(1, n + 1)' итерирует по значениям от 1 до n (включительно), представляя каждую
# ступеньку лесенки. Внутренний цикл 'for j in range(1, i + 1)' итерирует по значениям от 1 до текущего значения
# внешнего цикла 'i', выводя числа от 1 до i.

# Шаг №3. - Теперь нам нужно выводить результат
# Внутренний цикл выводит числа от 1 до i без пробелов, а затем вызывается 'print()' без аргументов для перехода
# на новую строку, создавая эффект "лесенки".

# Пример запуска программы:
# Введите натуральное число n (n ≤ 9): 3
# 1
# 12
# 123

# Программа создает лесенку, где каждая строка содержит числа от 1 до i,
# в соответствии с введенным пользователем значением n.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
  #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Циклы ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~#
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Для настольной игры используются карточки с номерами от 1 до N.
# Одна карточка потерялась. Найдите ее, зная номера оставшихся карточек.

# Дано число N, далее N − 1 номер оставшихся карточек (различные числа от 1 до N).

# Программа должна вывести номер потерянной карточки.

# Ввод - Input                  Вывод - Output
# 5                                        5
# 1
# 2
# 3
# 4

# Ввод - Input                  Вывод - Output
# 5                                        4
# 3
# 5
# 2
# 1

# 4                                         4
# 3
# 2
# 4

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

# И так. Так как задача не из простых, думаю, что можно попробовать использовать свойства арифметической прогрессии
# для нахождения потерянной карточки.
# Сумма всех чисел от 1 до N равна (N * (N + 1)) // 2,
# а сумма оставшихся карточек вычисляется из введенных значений.
# Разность этих сумм будет номером потерянной карточки. (как мне кажется)

# Ввод числа N
N = int(input("Введите число N: "))
# Инициализация суммы всех чисел от 1 до N
total_sum = (N * (N + 1)) // 2
# Инициализация суммы оставшихся карточек
remaining_sum = 0
# Ввод N-1 номеров оставшихся карточек и вычисление их суммы
for _ in range(N - 1):
    remaining_sum += int(input("Введите номер оставшейся карточки: "))
# Вычисление номера потерянной карточки
lost_card = total_sum - remaining_sum
# Вывод результата
print("Номер потерянной карточки:", lost_card)

# Проверяем работу программы
# Вводим данные из задачи, для проверки
# На ввод у нас такие данные:
# 5
# 1
# 2
# 3
# 4

# На выходе (выводе) = должны быть такие данные:
# № потерянной карточки 5

# Вводим далее данные из задачи, для проверки
# На ввод у нас такие данные:
# 5
# 3
# 5
# 2
# 1

# На выходе (выводе) = должны быть такие данные:
# № потерянной карточки 4

# Вводим последние данные из задачи, для проверки
# На ввод у нас такие данные:
# 4
# 3
# 2
# 4

# На выходе (выводе) = должны быть такие данные:
# № потерянной карточки 1

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
# Можно, так же, как мне кажется записать решение иначе, используя встроенные функции 'sum' и 'range':

# Ввод числа N
N = int(input("Введите число N: "))
# Инициализация суммы оставшихся карточек
remaining_sum = sum(int(input("Введите номер оставшейся карточки: ")) for _ in range(N - 1))
# Вычисление номера потерянной карточки
lost_card = (N * (N + 1)) // 2 - remaining_sum
# Вывод результата
print("Номер потерянной карточки:", lost_card)

# Этот вариант использует генератор списка и встроенную функцию sum для вычисления суммы оставшихся карточек.
# Разность сумм всех карточек и суммы оставшихся даст номер потерянной карточки.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓
# Исключающее ИЛИ - XOR

# a ⊕ a = 0
# a ⊕ 0 = a
# a ⊕ b = b ⊕ a
# a ⊕ b ⊕ a = b

# Ввод числа N
N = int(input("Введите число N: "))
# Инициализация XOR всех чисел от 1 до N
xor_total = 0
for i in range(1, N + 1):
    xor_total ^= i
# Инициализация XOR оставшихся карточек
xor_remaining = 0
for _ in range(N - 1):
    xor_remaining ^= int(input("Введите номер оставшейся карточки: "))
# Вычисление номера потерянной карточки
lost_card = xor_total ^ xor_remaining
# Вывод результата
print("Номер потерянной карточки:", lost_card)

# Когда мы выполняем XOR всех чисел от 1 до N и XOR оставшихся карточек, результат будет номером потерянной карточки.

# Подробнее шаг за шагом:

# Шаг №1. - Ввод числа N
N = int(input("Введите число N: "))
# Пользователь вводит число N с клавиатуры. Это число представляет собой общее количество карточек.

# Шаг №2. - Инициализация XOR всех чисел от 1 до N
xor_total = 0
for i in range(1, N + 1):
    xor_total ^= i
# Инициализируем переменную 'xor_total' нулем.
# Затем, используя цикл 'for', проходим по числам от 1 до N (включительно) и
# выполняем операцию XOR с текущим значением. Это создает XOR всех чисел от 1 до N.

# Шаг №3. - Инициализация XOR для оставшихся карточек
xor_remaining = 0
for _ in range(N - 1):
    xor_remaining ^= int(input("Введите номер оставшейся карточки: "))
# Инициализируем переменную 'xor_remaining' нулем.
# Затем, используя цикл 'for', просим пользователя ввести N-1 оставшихся карточек и выполняем операцию XOR
# с каждым введенным числом.

# Шаг №4. - Вычисление номера потерянной карточки
lost_card = xor_total ^ xor_remaining
# Вычисляем номер потерянной карточки, выполнив операцию XOR между 'xor_total' (XOR всех чисел от 1 до N) и
# 'xor_remaining' (XOR оставшихся карточек).

# Шаг №5. - Вывод результата
print("Номер потерянной карточки:", lost_card)
# Мы выводим номер потерянной карточки на экран

# Таким образом, в данном подходе к решению задачи используется свойство XOR
# для определения номера потерянной карточки без явного вычисления сумм.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# По данному целому числу N распечатайте все квадраты натуральных чисел, не превосходящие N, в порядке возрастания.
#
# Input              Output
# 50                 1 4 9 16 25 36 49
# 10                 1 4 9
# 9                  1 4 9

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓
# Ввод числа N
N = int(input("Введите целое число N: "))
# Инициализация переменной для хранения текущего натурального числа
i = 1
# Вывод квадратов натуральных чисел, не превосходящих N, в порядке возрастания
while i**2 <= N:
    print(i**2, end=' ')
    i += 1
# Этот код выводит все квадраты натуральных чисел, которые не превосходят N, в порядке возрастания.
# Например из условий задачи:
" Введите целое число N: 50 "
"1 4 9 16 25 36 49 "
# Затем:
" Введите целое число N: 10 "
" 1 4 9 "
# И наконец:
" Введите целое число N: 9 "
" 1 4 9 "
# Каждое число в выводе - это квадрат натурального числа, и все они не превосходят введенное число N.

# Шаг №1. - Ввод числа N
N = int(input("Введите целое число N: "))
# Пользователь вводит целое число N с клавиатуры.

# Шаг №2. - Запись переменной для хранения натурального числа
i = 1
# Записываем в переменную i значением 1.
# Эта переменная будет использоваться для отслеживания текущего натурального числа.

# Шаг №3. - Вывод квадратов натуральных чисел, не превосходящих N, в порядке возрастания
while i**2 <= N:
    print(i**2, end=' ')
    i += 1
# Для решения данной задачи думаю стоит использовать цикл 'while', который выполняется,
# пока квадрат текущего натурального числа не превысит N.
# На каждом шаге цикла мы выводим квадрат текущего натурального числа и увеличиваем 'i' на 1.

# Примеры в работе с программой:
" Введите целое число N: 50 "
" 1 4 9 16 25 36 49 "
# Разбор по шагам
#1. Вводим N, например, 50.
#2. Инициализируем i равным 1.
#3. Проверяем, что 1^2 (квадрат 1) не превосходит 50 - выводим 1, увеличиваем i на 1.
#4. Проверяем, что 2^2 (квадрат 2) не превосходит 50 - выводим 4, увеличиваем i на 1.
#5. Продолжаем аналогично, пока квадрат текущего i не превысит 50.

# Таким образом с помощью этого кода Мы выводим квадраты натуральных чисел, не превосходящие введенное число N.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
# Используем цикл 'for' и функцию 'range'
N = int(input("Введите целое число N: "))
# Используем цикл for и функцию range для итерации по квадратам
for i in range(1, int(N**0.5) + 1):
    print(i**2, end=' ')
# Этот код также выводит квадраты натуральных чисел, не превосходящие N, в порядке возрастания.

# Шаг №1. - Ввод числа N
N = int(input("Введите целое число N: "))

# Шаг №2. - Использование цикла for и функции range
for i in range(1, int(N**0.5) + 1):
    print(i**2, end=' ')

# Здесь мы используем цикл for для итерации по значениям от 1 до квадратного корня из N (включительно).
# Такой подход позволяет нам избежать создания лишних чисел, которые не превосходят N.

# Функция range(1, int(N**0.5) + 1) создает числа от 1 до int(N**0.5) включительно.

# Для каждого числа i в этом диапазоне мы выводим его квадрат.

# Это более компактный способ записи, который также эффективен для решения этой задачи.



