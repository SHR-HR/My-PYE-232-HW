# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Дата: 29-30 ноября 2023
'''
'''
Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
Дисциплина: Основы программирования на Python
'''
'''
Урок №10 от 29.11.2023 (по факту с 6.11.2023 по 29.11.2023 - Урок №11)
Домашнее задание №9: Сортировка, поиск, регулярные выражения
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
При выполнении (практической) домашней работы, основной алгоритм решения задачи должен быть описан в виде функции,
получающей в качестве параметра список (а также, возможно, и дополнительные параметры).
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №1.

Дано: ↓

Заданы M строк символов, которые вводятся с клавиатуры. Найти количество символов в самой длинной строке.
Выровнять строки по самой длинной строке, поставив перед каждой строкой соответствующее количество звёздочек.

Input:

da
net
poka


Output:
**da
*net
poka

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1.
'''
def align_strings(strings):
    # Находим самую длинную строку
    max_length = max(len(s) for s in strings)
    # Выводим строки, выровненные по самой длинной строке
    for s in strings:
        padding = max_length - len(s)
        stars = '*' * padding
        print(stars + s)
# Пример использования
input_strings = ["da", "net", "poka"]
align_strings(input_strings)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Определение функции align_strings:
'''
def align_strings(strings):
''''
Здесь создается функция align_strings, которая принимает в качестве аргумента список строк (strings).
''''

'''
Шаг №2. ↓ - Нахождение максимальной длины строки:
'''
max_length = max(len(s) for s in strings)
'''
Эта строка определяет переменную max_length, которая содержит максимальную длину строки в списке strings.
Она использует генератор списка и функцию max для нахождения максимальной длины.
'''

'''
Шаг №3. ↓ - Цикл по строкам для выравнивания:
'''
for s in strings:
''''
Здесь начинается цикл for, который перебирает каждую строку s в списке strings.
''''

'''
Шаг №4. ↓ - Вычисление отступа и добавление звездочек:
'''
padding = max_length - len(s)
stars = '*' * padding
'''
Для каждой строки вычисляется значение padding, равное разнице между максимальной длиной строки и текущей длиной
строки. Затем создается строка stars, содержащая соответствующее количество звездочек (*), равное значению padding.
'''

'''
Шаг №5. ↓ - Вывод выровненной строки:
'''
print(stars + s)
'''
Здесь строка, состоящая из звездочек и текущей строки, выводится на экран.
'''

'''
Шаг №6. ↓ - Пример использования:
'''
input_strings = ["da", "net", "poka"]
align_strings(input_strings)
'''
В этом примере создается список input_strings, содержащий строки.
Затем вызывается функция align_strings с этим списком в качестве аргумента,
что приводит к выравниванию и выводу строк.
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2.
'''
import re
def align_strings(strings):
    # Находим самую длинную строку
    max_length = max(len(s) for s in strings)
    # Выводим строки, выровненные по самой длинной строке
    for s in strings:
        padding = max_length - len(s)
        stars = '*' * padding
        aligned_string = re.sub(r'^', stars, s)
        print(aligned_string)
# Пример использования
input_strings = ["da", "net", "poka"]
align_strings(input_strings)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля регулярных выражений (re):
'''
import re
'''
Эта строка импортирует модуль регулярных выражений re, который предоставляет функции для работы с 
регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции align_strings:
'''
def align_strings(strings):
''''
Здесь создается функция align_strings, принимающая в качестве аргумента список строк (strings).
''''

'''
Шаг №3. ↓ - Нахождение максимальной длины строки:
'''
max_length = max(len(s) for s in strings)
'''
Эта строка определяет переменную max_length, содержащую максимальную длину строки в списке strings,
так же, как и в предыдущем коде.
'''

'''
Шаг №4. ↓ - Вывод строк, выровненных по самой длинной строке, с использованием регулярных выражений:
'''
for s in strings:
    padding = max_length - len(s)
    stars = '*' * padding
    aligned_string = re.sub(r'^', stars, s)
    print(aligned_string)
'''
В этом блоке мы используем цикл for, чтобы перебрать каждую строку в списке strings. Для каждой строки вычисляется
padding (разница между максимальной длиной строки и текущей длиной строки), создается строка stars, состоящая из
звездочек, а затем применяется функция re.sub. Эта функция заменяет начало строки (^) строкой из звездочек.
Таким образом, мы добавляем звездочки перед каждой строкой для выравнивания.
'''

'''
Шаг №5. ↓ - Пример использования:
'''
input_strings = ["da", "net", "poka"]
align_strings(input_strings)
'''
Этот код создает список input_strings, содержащий строки, и вызывает функцию align_strings с этим списком в
качестве аргумента.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №3. - Этот более компактный код выполняет ту же задачу,
что и предыдущий, но использует более краткие конструкции, такие как map, max, и условный оператор внутри re.sub.
'''
iimport re

def align_strings(strings):
    max_length = max(map(len, strings))
    for s in strings:
        print(re.sub(r'^', '*' * (max_length - len(s)), s))

# Пример использования
input_strings = ["da", "net", "poka"]
align_strings(input_strings)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля регулярных выражений (re):
'''
import re
'''
Эта строка импортирует модуль регулярных выражений re,
который используется для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции align_strings:
'''
def align_strings(strings):
''''
Здесь создается функция align_strings, принимающая в качестве аргумента список строк (strings).
''''

'''
Шаг №3. ↓ - Нахождение максимальной длины строки:
'''
max_length = max(map(len, strings))
'''
В этой строке используется map(len, strings), чтобы получить длины всех строк, а затем max находит максимальную длину.
'''

'''
Шаг №4. ↓ - Вывод строк, выровненных по самой длинной строке,
с использованием регулярных выражений и условного оператора:
'''
for s in strings:
    print(re.sub(r'^', '*' * (max_length - len(s)), s))
'''
В этом блоке используется цикл for, чтобы перебрать каждую строку в списке strings.
Для каждой строки используется re.sub, чтобы заменить начало строки (^) строкой, состоящей из звездочек,
количество которых определяется как разница между максимальной длиной строки и текущей длиной строки.
'''

'''
Шаг №5. ↓ - Пример использования:
'''
input_strings = ["da", "net", "poka"]
align_strings(input_strings)
'''
Этот код создает список input_strings, содержащий строки, и вызывает функцию align_strings с этим списком
в качестве аргумента.
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №2.

Дано: ↓

Дан одномерный массив числовых значений, насчитывающий N элементов. Добавить к элементам массива такой новый элемент,
чтобы сумма элементов с положительными значениями стала бы равна модулю суммы элементов с отрицательными значениями.

Output:

[-3,-2,1,2,3,4]
10
5
need 5

[-3,-2,1,2,3,4,5]

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1.
'''
Massive = [-3, -2, 1, 2, 3, 4]
sumPositive = 0
sumNegative = 0
for number in range(0, len(Massive)):
    if Massive[number] > 0:
        sumPositive += Massive[number]
    else:
        sumNegative += abs(Massive[number])
diff = abs(sumNegative - sumPositive)
if sumPositive < sumNegative:
    Massive.append(diff)
else:
    Massive.append(-diff)
print(f'Сумма отрицательных = {sumNegative}')
print(f'Сумма положительных = {sumPositive}')
print(f'Разница = {diff}')

print(Massive)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Исходный массив:
'''
Massive = [-3, -2, 1, 2, 3, 4]
'''
Шаг №2. ↓ - Инициализация переменных для сумм:
'''
sumPositive = 0
sumNegative = 0
'''
Шаг №3. ↓ - Цикл по элементам массива:
'''
for number in range(0, len(Massive)):
'''
Шаг №4. ↓ - Проверка условия: если элемент положительный, добавляем к сумме положительных:
'''
if arr[number] > 0:
    sumPositive += Massive[number]
'''
Шаг №5. ↓ - В противном случае (если элемент отрицательный), добавляем его абсолютное значение к сумме отрицательных:
'''
else:
sumNegative += abs(Massive[number])
'''
Шаг №6. ↓ - Вычисление разницы между суммами отрицательных и положительных элементов:
'''
diff = abs(sumNegative - sumPositive)
'''
Шаг №7. ↓ - Проверка условия и добавление нового элемента в массив:
'''
if sumPositive < sumNegative:
    Massive.append(diff)
else:
    Massive.append(-diff) #или так Massive.append(diff) - чтобы соответствовать условию
'''
Если сумма положительных меньше суммы отрицательных, добавляем разницу;
в противном случае, добавляем отрицательное значение разницы.
'''
'''
Шаг №8. ↓ - Вывод результатов:
'''
print(f'Сумма отрицательных = {sumNegative}')
print(f'Сумма положительных = {sumPositive}')
print(f'Разница = {diff}')
'''
Шаг №9. ↓ - Вывод измененного массива:
'''
print(Massive)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2.
'''
def balance_array(arr):
    # Разделить массив на положительные и отрицательные элементы
    positive_numbers = [x for x in arr if x > 0]
    negative_numbers = [x for x in arr if x < 0]
    # Вычислить суммы
    sum_positive = sum(positive_numbers)
    sum_negative = sum(negative_numbers)
    # Добавить новый элемент
    new_element = abs(sum_negative) - sum_positive
    arr.append(new_element)
    return arr
# Исходный массив
original_array = [-3, -2, 1, 2, 3, 4]

# Добавить новый элемент к массиву
result_array = balance_array(original_array.copy())  # Используем копию массива, чтобы не изменить оригинал

# Вывести результат
print(result_array)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ Определение функции balance_array
'''
def balance_array(arr):
    # Разделить массив на положительные и отрицательные элементы
    positive_numbers = [x for x in arr if x > 0]
    negative_numbers = [x for x in arr if x < 0]

    # Вычислить суммы
    sum_positive = sum(positive_numbers)
    sum_negative = sum(negative_numbers)

    # Добавить новый элемент
    new_element = abs(sum_negative) - sum_positive
    arr.append(new_element)

    return arr
'''
Шаг 2: ↓ Создание исходного массива
'''
original_array = [-3, -2, 1, 2, 3, 4]
'''
Шаг 3: ↓ Вызов функции balance_array с копией исходного массива
'''
result_array = balance_array(original_array.copy())
'''
Используем копию массива, чтобы не изменить оригинал
'''
'''
Шаг 4: ↓ Вывод результата
'''
print(result_array)

'''
А ЧТО В НУТРИ!!!??? КИШОЧКИ!
'''
'''
Так давай разберем, что происходит внутри функции balance_array:
'''
'''
1. Создание списков положительных и отрицательных чисел:
'''
positive_numbers = [x for x in arr if x > 0]
negative_numbers = [x for x in arr if x < 0]
'''
Создаем два списка: positive_numbers содержит все положительные
числа из массива, а negative_numbers — все отрицательные.
'''
'''
2. Вычисление сумм положительных и отрицательных чисел:
'''
sum_positive = sum(positive_numbers)
sum_negative = sum(negative_numbers)
'''
Считаем суммы элементов в созданных списках.
'''
'''
3. Добавление нового элемента:
'''
new_element = abs(sum_negative) - sum_positive
arr.append(new_element)
'''
Вычисляем новый элемент как разницу между модулем суммы отрицательных и суммой положительных,
и добавляем его в конец массива.
'''
'''
4. Возврат измененного массива:
'''
return arr
'''
Функция возвращает измененный массив.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2+1. - Использование цикла и условных выражений
'''
arr = [-3, -2, 1, 2, 3, 4]
sumPositive = sum(x for x in arr if x > 0)
sumNegative = sum(abs(x) for x in arr if x < 0)
diff = abs(sumNegative - sumPositive)
if sumPositive < sumNegative:
    arr.append(diff)
else:
    arr.append(-diff)
print(f'Сумма отрицательных = {sumNegative}')
print(f'Сумма положительных = {sumPositive}')
print(f'Разница = {diff}')
print(arr)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ Инициализация списка
'''
arr = [-3, -2, 1, 2, 3, 4]
'''
Создаем список arr с элементами [-3, -2, 1, 2, 3, 4].
'''
'''
Шаг №2. ↓ Вычисление суммы положительных чисел
'''
sumPositive = sum(x for x in arr if x > 0)
'''
Вычисляем сумму положительных чисел из списка arr и сохраняем результат в переменной sumPositive.
'''
'''
Шаг №3. ↓ Вычисление суммы абсолютных значений отрицательных чисел
'''
sumNegative = sum(abs(x) for x in arr if x < 0)
'''
Вычисляем сумму абсолютных значений отрицательных чисел из списка arr и сохраняем результат в переменной sumNegative.
'''
'''
Шаг №4. ↓ Вычисление разницы между суммами
'''
diff = abs(sumNegative - sumPositive)
'''
Вычисляем разницу между суммой абсолютных значений отрицательных чисел и суммой положительных чисел, 
сохраняем результат в переменной diff.
'''
'''
Шаг №5. ↓ Добавление нового элемента в список
'''
if sumPositive < sumNegative:
    arr.append(diff)
else:
    arr.append(-diff)
'''
Если сумма положительных чисел меньше суммы отрицательных, добавляем новый элемент diff в список.
В противном случае, добавляем -diff.
'''
'''
Шаг №6. ↓ Вывод результатов
'''
print(f'Сумма отрицательных = {sumNegative}')
print(f'Сумма положительных = {sumPositive}')
print(f'Разница = {diff}')
print(arr)
'''
Выводим информацию о сумме отрицательных чисел, сумме положительных чисел, разнице и измененном списке arr.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2+1+1. - Использование функций sum и abs с map
'''
arr = [-3, -2, 1, 2, 3, 4]
sumPositive = sum(x for x in arr if x > 0)
sumNegative = sum(abs(x) for x in arr if x < 0)
diff = abs(sumNegative - sumPositive)
if sumPositive < sumNegative:
    arr.append(diff)
else:
    arr.append(-diff)
print(f'Сумма отрицательных = {sumNegative}')
print(f'Сумма положительных = {sumPositive}')
print(f'Разница = {diff}')
print(arr)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ Инициализация списка
'''
arr = [-3, -2, 1, 2, 3, 4]
'''
Создаем список arr с элементами [-3, -2, 1, 2, 3, 4].
'''
'''
Шаг №2. ↓ Вычисление суммы положительных чисел с использованием filter и sum
'''
sumPositive = sum(filter(lambda x: x > 0, arr))
'''
Используем функцию filter для отфильтровывания положительных чисел из списка arr,
затем вычисляем их сумму и сохраняем результат в переменной sumPositive.
'''
'''
Шаг №3. ↓ Вычисление суммы абсолютных значений отрицательных чисел с использованием filter, map и sum
'''
sumNegative = sum(map(abs, filter(lambda x: x < 0, arr)))
'''
Используем функцию filter для отфильтровывания отрицательных чисел из списка arr, затем с помощью map преобразуем 
их в абсолютные значения, и, наконец, вычисляем сумму полученных абсолютных значений и сохраняем 
результат в переменной sumNegative.
'''
'''
Шаг №4. ↓ Вычисление разницы между суммами
'''
diff = abs(sumNegative - sumPositive)
'''
Вычисляем разницу между суммой абсолютных значений отрицательных
чисел и суммой положительных чисел, сохраняем результат в переменной diff.
'''
'''
Шаг №5. ↓ Добавление нового элемента в список
'''
if sumPositive < sumNegative:
    arr.append(diff)
else:
    arr.append(-diff)
'''
Если сумма положительных чисел меньше
суммы отрицательных, добавляем новый элемент diff в список.
В противном случае, добавляем -diff.
'''
'''
Шаг №6. ↓ Вывод результатов
'''
print(f'Сумма отрицательных = {sumNegative}')
print(f'Сумма положительных = {sumPositive}')
print(f'Разница = {diff}')
print(arr)
'''
Выводим информацию о сумме отрицательных чисел, сумме положительных чисел, разнице и измененном списке arr.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Регулярные выражения
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №1.
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Дано: ↓

Напишите программу, в которой возвращаются домены из списка e-mail адресов.

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1. ↓
'''
import re

def extract_domains(email_list):
    domain_pattern = r'@([a-zA-Z0-9.-]+)'
    domains = []

    for email in email_list:
        match = re.search(domain_pattern, email)
        if match:
            domain = match.group(1)
            domains.append(domain)

    return domains

# Пример использования:
email_addresses = [
    'user1@example.com',
    'user2@gmail.com',
    'user3@yahoo.com',
    'user4@hotmail.com'
]

result = extract_domains(email_addresses)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Эта строка импортирует модуль re, который предоставляет
функционал для работы с регулярными выражениями в Python.
'''
import re

'''
Шаг №2. ↓ - Мы создаем функцию extract_domains, которая принимает список email-адресов email_list.
Затем определяем регулярное выражение @([a-zA-Z0-9.-]+), которое будет использоваться для извлечения доменов
из email-адресов. Это выражение ищет символ "@" и захватывает последовательность символов, состоящую из букв 
(верхнего и нижнего регистра), цифр, точек и дефисов.
'''
def extract_domains(email_list):
    domain_pattern = r'@([a-zA-Z0-9.-]+)'
    domains = []

'''
Шаг №3. ↓ - Мы используем цикл for для перебора каждого email-адреса в списке.
Для каждого адреса мы применяем re.search для поиска соответствия с регулярным выражением в адресе.
Если соответствие найдено (if match:), мы используем match.group(1) для извлечения захваченной части (домена) и 
добавляем его в список domains.
'''
for email in email_list:
    match = re.search(domain_pattern, email)
    if match:
        domain = match.group(1)
        domains.append(domain)

'''
Шаг №4. ↓ - Функция возвращает список извлеченных доменов.
'''
return domains

'''
Шаг №5. ↓ - В конце программы мы создаем пример списка email-адресов и вызываем функцию extract_domains для извлечения
доменов. Результат затем выводится с помощью print. В данном случае, вывод будет содержать список извлеченных доменов.
'''
# Пример использования:
email_addresses = [
    'user1@example.com',
    'user2@gmail.com',
    'user3@yahoo.com',
    'user4@hotmail.com'
]

result = extract_domains(email_addresses)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓
'''
import re
from email.utils import parseaddr

def extract_domains(email_list):
    domains = []

    for email in email_list:
        _, email_address = parseaddr(email)
        if '@' in email_address:
            _, domain = email_address.split('@', 1)
            domains.append(domain)

    return domains

# Пример использования:
email_addresses = [
    'user1@example.com',
    'user2@gmail.com',
    'user3@yahoo.com',
    'user4@hotmail.com',
    'user5@company.co.uk'
]

result = extract_domains(email_addresses)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт библиотек
'''
import re
from email.utils import parseaddr
'''
Здесь мы импортируем модуль re для работы с регулярными выражениями и функцию parseaddr из модуля email.utils,
которая поможет извлечь чистый email-адрес из строки.
'''

'''
Шаг №2. ↓ - Определение функции extract_domains
'''
def extract_domains(email_list):
    domains = []

    for email in email_list:
        _, email_address = parseaddr(email)
        if '@' in email_address:
            _, domain = email_address.split('@', 1)
            domains.append(domain)

    return domains
'''
Здесь создается функция extract_domains, которая принимает список email-адресов
email_list и возвращает список извлеченных доменов.
'''

'''
Шаг №3. ↓ - Цикл по email-адресам
'''
for email in email_list:
'''
Цикл начинается, перебирая каждый email-адрес в списке.
'''

'''
Шаг №4. ↓ - Извлечение email-адреса
'''
_, email_address = parseaddr(email)
'''
Используем parseaddr для извлечения чистого email-адреса из строки. Первое значение (представленное "_")
возвращает имя, которое мы игнорируем, а второе значение (email_address) содержит чистый email-адрес.
'''

'''
Шаг №5. ↓ - Проверка наличия символа "@" в email-адресе
'''
if '@' in email_address:
'''
Проверяем, содержит ли email-адрес символ "@".
'''

'''
Шаг №6. ↓ - Извлечение домена
'''
_, domain = email_address.split('@', 1)
'''
Если "@" есть, разделяем email-адрес по символу "@" и получаем часть после "@" (домен). Мы используем split('@', 1),
чтобы разделить строку только по первому символу "@".
'''

'''
Шаг №7. ↓ - Добавление домена в список
'''
domains.append(domain)
'''
Добавляем извлеченный домен в список domains.
'''

'''
Шаг №8. ↓ - Возврат результата
'''
return domains
'''
Функция завершается, возвращая список извлеченных доменов.
'''

'''
Шаг №9. ↓ - Пример использования
'''
email_addresses = [
    'user1@example.com',
    'user2@gmail.com',
    'user3@yahoo.com',
    'user4@hotmail.com',
    'user5@company.co.uk'
]

result = extract_domains(email_addresses)
print(result)
'''
Создается пример списка email-адресов email_addresses, и затем вызывается функция extract_domains для
извлечения доменов. Результат выводится с помощью print.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №3. ↓
'''
import re
def extract_domains(email_list):
    email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    domains = []
    for email in email_list:
        matches = re.findall(email_pattern, email)
        for match in matches:
            _, domain = match.split('@', 1)
            domains.append(domain)
    return domains
# Пример использования:
email_addresses = [
    'user1@example.com',
    'user2@gmail.com',
    'user3@yahoo.com',
    'user4@hotmail.com',
    'john.doe@company.co.uk',
    'info+test@email-server.com'
]

result = extract_domains(email_addresses)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт библиотеки re
'''
import re
'''
На этом шаге мы импортируем модуль re, который предоставляет функционал для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции extract_domains
'''
def extract_domains(email_list):
    email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    domains = []
'''
Здесь мы определяем функцию extract_domains, которая принимает на вход список email-адресов email_list.
Также мы создаем регулярное выражение email_pattern, которое будет использоваться для поиска email-адресов в тексте.
'''

'''
Шаг №3. ↓ - Цикл обработки каждого email-адреса
'''
for email in email_list:
    matches = re.findall(email_pattern, email)
    for match in matches:
        _, domain = match.split('@', 1)
        domains.append(domain)
'''
На этом этапе мы используем цикл for, чтобы перебрать каждый email-адрес в списке email_list.
Для каждого адреса мы используем re.findall для поиска всех соответствий регулярному выражению в строке.
Затем мы используем внутренний цикл для перебора найденных соответствий.

Для каждого соответствия мы используем split('@', 1), чтобы разделить строку email-адреса на локальную часть и домен.
Домен добавляется в список domains.
'''

'''
Шаг №4. ↓ - Возвращение результата
'''
return domains
'''
На последнем шаге функция возвращает список извлеченных доменов.
'''

'''
КАК ПРИМЕР РАБАОТЫ КОДА
'''
email_addresses = [
    'user1@example.com',
    'user2@gmail.com',
    'user3@yahoo.com',
    'user4@hotmail.com',
    'john.doe@company.co.uk',
    'info+test@email-server.com'
]

result = extract_domains(email_addresses)
print(result)
'''
В этом примере мы создаем список email-адресов и вызываем функцию extract_domains для извлечения доменов.
Результат выводится с помощью print.
'''

'''
Регулярное выражение email_pattern
'''
email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
'''
Регулярное выражение ищет следующие компоненты email-адреса:

Локальная часть: [A-Za-z0-9._%+-]+ - буквы, цифры, точки, подчеркивания, проценты, знаки плюс и дефисы.
Символ "@".
Домен: [A-Za-z0-9.-]+ - буквы, цифры, точки и дефисы.
Точка перед доменным уровнем: \..
Доменный уровень: [A-Z|a-z]{2,} - две или более буквы в верхнем или нижнем регистре.
Границы слова: \b - чтобы избежать частичного соответствия внутри других слов.
Это регулярное выражение позволяет учесть различные форматы email-адресов.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №4. ↓
'''
import re
def extract_domains(emails):
    domain_pattern = re.compile(r'@([a-zA-Z0-9.-]+)')
    domains = [domain_pattern.search(email).group(1) for email in emails if domain_pattern.search(email)]
    return domains
# Пример использования:
email_list = ["user1@example.com", "user2@gmail.com", "user3@yahoo.com"]
result_domains = extract_domains(email_list)
print(result_domains)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Эта строка импортирует модуль re, который предоставляет функциональность для работы
с регулярными выражениями в Python.
'''
import re
'''
Шаг №2. ↓ - Это определение функции extract_domains, которая принимает список emails в качестве аргумента.
В этой функции будет производиться извлечение доменов из адресов электронной почты.
'''
def extract_domains(emails)
'''
Шаг №3. ↓ - Создается объект компилированного регулярного выражения (domain_pattern), который ищет символ @ в 
адресе электронной почты, захватывая последовательность символов, состоящую из букв (в верхнем и нижнем регистре), 
цифр, точек и дефисов. Эта последовательность символов представляет собой доменное имя.
'''
domain_pattern = re.compile(r'@([a-zA-Z0-9.-]+)')
'''
Шаг №4. ↓ - Эта строка использует генератор списка для создания списка domains. Для каждого адреса электронной почты
в списке emails, который соответствует регулярному выражению (domain_pattern.search(email) возвращает объект Match), 
извлекается группа (домен) с помощью .group(1). Условие if domain_pattern.search(email) проверяет,
что адрес электронной почты соответствует регулярному выражению перед извлечением домена.
'''
domains = [domain_pattern.search(email).group(1) for email in emails if domain_pattern.search(email)]
'''
Шаг №5. ↓ - Функция возвращает список извлеченных доменов.
'''
return domains
'''
Шаг №6. ↓ - Пример использования:

email_list = ["user1@example.com", "user2@gmail.com", "user3@yahoo.com"]: Создается список адресов электронной почты.
result_domains = extract_domains(email_list): Вызывается функция extract_domains с этим списком, и результат 
(список извлеченных доменов) сохраняется в переменной result_domains.
print(result_domains): Выводит на экран полученные домены.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №2.
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Дано: ↓

Напишите программу, в которой извлекаются слова, начинающиеся на гласную букву.

Решение:
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1. ↓
'''
import re
def extract_vowel_words(text):
    vowel_word_pattern = re.compile(r'\b[aeiouAEIOU][a-zA-Z]*\b')
    vowel_words = vowel_word_pattern.findall(text)
    return vowel_words
# Пример использования:
input_text = "Apple is a delicious fruit. Orange and avocado are also good."
result_vowel_words = extract_vowel_words(input_text)
print(result_vowel_words)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля re:
'''
import re
'''
Мы импортируем модуль re, который предоставляет функционал для работы с регулярными выражениями.
'''

'''
Шаг №2. ↓ - Определение функции extract_vowel_words:
'''
def extract_vowel_words(text):
''''
Мы создаем функцию extract_vowel_words, которая принимает текст в качестве аргумента.
''''

'''
Шаг №3. ↓ - Создание регулярного выражения:
'''
vowel_word_pattern = re.compile(r'\b[aeiouAEIOU][a-zA-Z]*\b')
'''
Мы создаем регулярное выражение, которое ищет слова, начинающиеся на гласную букву. Разберем его:

\b: Граница слова, чтобы избежать частичных совпадений.
[aeiouAEIOU]: Одна из гласных букв (маленькая или большая).
[a-zA-Z]*: Ноль или более символов после первой буквы, чтобы охватить остальные символы слова.
\b: Граница слова в конце.
'''

'''
Шаг №4. ↓ - Применение регулярного выражения:
'''
vowel_words = vowel_word_pattern.findall(text)
'''
Мы используем метод findall для поиска всех совпадений в тексте и сохранения их в списке vowel_words.
'''

'''
Шаг №5. ↓ - Возвращение результата:
'''
return vowel_words
'''
Функция возвращает список слов, начинающихся на гласную букву.
'''

'''
Шаг №6. ↓ - Пример использования функции:
'''
input_text = "Apple is a delicious fruit. Orange and avocado are also good."
result_vowel_words = extract_vowel_words(input_text)
print(result_vowel_words)
'''
Мы применяем функцию к примеру текста и выводим результат.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓
'''
import re
def extract_vowel_words_from_list(word_list):
    # Регулярное выражение для поиска слов, начинающихся на гласную букву
    vowel_word_pattern = r'\b[АЕИОУЫЭЮЯаеиоуыэюя]\w*\b'
    # Используем re.findall для поиска всех соответствий в каждом слове списка
    vowel_words = [match.group() for word in word_list for match in re.finditer(vowel_word_pattern, word)]
    return vowel_words
# Пример использования:
words_example = ["Ананас", "Арбуз", "Банан", "Яблоко", "Персик"]
result = extract_vowel_words_from_list(words_example)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт библиотеки re:
'''
import re
'''
Эта строка импортирует модуль re, который предоставляет функционал для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции extract_vowel_words_from_list:
'''
def extract_vowel_words_from_list(word_list):
    vowel_word_pattern = r'\b[АЕИОУЫЭЮЯаеиоуыэюя]\w*\b'
    vowel_words = [match.group() for word in word_list for match in re.finditer(vowel_word_pattern, word)]
    return vowel_words
'''
Здесь мы создаем функцию extract_vowel_words_from_list, которая принимает на вход список слов word_list.
Внутри функции определяется регулярное выражение vowel_word_pattern, предназначенное для поиска слов,
начинающихся на гласную букву в русском алфавите. Затем используется генератор списка для извлечения всех соответствий
в каждом слове из списка.
'''

'''
Шаг №3. ↓ - Пример использования:
'''
words_example = ["Ананас", "Арбуз", "Банан", "Яблоко", "Персик"]
result = extract_vowel_words_from_list(words_example)
print(result)
'''
В этом примере создается список слов words_example, и функция extract_vowel_words_from_list вызывается с этим списком.
Результат затем выводится с помощью print.
'''

'''
Регулярное выражение vowel_word_pattern
'''
vowel_word_pattern = r'\b[АЕИОУЫЭЮЯаеиоуыэюя]\w*\b'

'''
Это регулярное выражение ищет следующие компоненты в слове:

\b: Граница слова, чтобы избежать частичных соответствий внутри других слов.
[АЕИОУЫЭЮЯаеиоуыэюя]: Гласная буква в русском алфавите (в верхнем или нижнем регистре).
\w*: Ноль или более букв (включая цифры и подчеркивание) после гласной.
\b: Граница слова.
'''

'''
Шаг №4. ↓ - Вывод результата:
'''
print(result)
'''
Результат выполнения программы выводится на экран. 
В данном случае, это список слов, начинающихся на гласную букву в русском алфавите.
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №3.
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Дано: ↓

Напишите программу, в которой разбивается строка по нескольким разделителям.

Решение:
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1. ↓
'''
import re
def split_string_by_delimiters(input_string, delimiters):
    pattern = '|'.join(map(re.escape, delimiters))
    parts = re.split(pattern, input_string)
    return parts
# Пример использования:
input_string = "This,is;an-example string"
delimiters = [',', ';', '-']
result_parts = split_string_by_delimiters(input_string, delimiters)
print(result_parts)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля re:
'''
import re
'''
Мы импортируем модуль re, который предоставляет функционал для работы с регулярными выражениями.
'''

'''
Шаг №2. ↓ - Определение функции split_string_by_delimiters:
'''
def split_string_by_delimiters(input_string, delimiters):
''''
Мы создаем функцию split_string_by_delimiters, которая принимает строку и список разделителей в качестве аргументов.
''''

'''
Шаг №3. ↓ - Создание регулярного выражения:
'''
pattern = '|'.join(map(re.escape, delimiters))
'''
Мы создаем регулярное выражение, объединяя разделители с использованием символа | (или).
Функция re.escape используется для экранирования специальных символов, чтобы они интерпретировались буквально.
'''

'''
Шаг №4. ↓ - Применение регулярного выражения:
'''
parts = re.split(pattern, input_string)
'''
Мы используем метод split для разделения строки на части в местах, где встречаются разделители,
определенные в регулярном выражении.
'''

'''
Шаг №5. ↓ - Возвращение результата:
'''
return parts
'''
Функция возвращает список частей, полученных в результате разделения строки.
'''

'''
Шаг №6. ↓ - Пример использования функции:
'''
input_string = "This,is;an-example string"
delimiters = [',', ';', '-']
result_parts = split_string_by_delimiters(input_string, delimiters)
print(result_parts)
'''
Мы применяем функцию к примеру строки с разделителями и выводим результат.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓
'''
import re
def split_string_by_delimiters(input_string, delimiters):
    # Создаем регулярное выражение с использованием символьного класса
    pattern = re.compile(f'[{re.escape("".join(delimiters))}]')
    # Разбиваем строку на части
    parts = pattern.split(input_string)
    return parts
# Пример использования:
input_string = "This,is;an-example string"
delimiters = [',', ';', '-']
result_parts = split_string_by_delimiters(input_string, delimiters)
print(result_parts)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля re:
'''
import re
'''
Импортируем модуль re, который предоставляет функционал для работы с регулярными выражениями.
'''

'''
Шаг №2. ↓ - Определение функции split_string_by_delimiters:
'''
def split_string_by_delimiters(input_string, delimiters):
''''
Создаем функцию split_string_by_delimiters, которая принимает строку (input_string) и список разделителей (delimiters).
''''

'''
Шаг №3. ↓ - Создание регулярного выражения:
'''
pattern = re.compile(f'[{re.escape("".join(delimiters))}]')
'''
Создаем регулярное выражение (pattern) с использованием символьного класса [...].
Мы используем re.escape для экранирования специальных символов разделителей.
'''

'''
Шаг №4. ↓ - Применение регулярного выражения:
'''
parts = pattern.split(input_string)
'''
Используем метод split регулярного выражения для разбиения строки на части в местах,
где встречаются указанные разделители.
'''

'''
Шаг №5. ↓ - Возвращение результата:
'''
return parts
'''
Функция возвращает список частей, полученных в результате разбиения строки.
'''

'''
Шаг №6. ↓ - Пример использования функции:
'''
input_string = "This,is;an-example string"
delimiters = [',', ';', '-']
result_parts = split_string_by_delimiters(input_string, delimiters)
print(result_parts)
'''
Создаем строку input_string и список разделителей delimiters.
Затем вызываем функцию split_string_by_delimiters с этими аргументами и выводим результат разбиения.
'''




