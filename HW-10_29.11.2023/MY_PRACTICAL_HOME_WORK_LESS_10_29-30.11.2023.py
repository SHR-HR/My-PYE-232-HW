# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Дата: 29-30 ноября 2023
'''
'''
Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
Дисциплина: Основы программирования на Python
'''
'''
Урок №10 от 29.11.2023 (по факту с 6.11.2023 по 29.11.2023 - Урок №11)
Практическая работа №9 Практическая работа №9: Сортировка, поиск, регулярные выражения
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
При выполнении практической работы,
основной алгоритм решения задачи должен быть описан в виде функции, получающей в качестве параметра список
(а также, возможно, и дополнительные параметры).
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №1.

Дано: ↓

Дана последовательность чисел, состоящая только из чисел 1, ..., 9.
Последовательность завершается числом 0. Каждое число записано в отдельной строке.
Подсчитайте, сколько раз в этой последовательности встречаются значения 1, 2, ..., 9.

Сохранять всю последовательность введенных чисел в списке нельзя.

Программа должна вывести ровно 9 чисел: количество единиц, двоек, ..., девяток в данной последовательности.

Input:

1
2
3
4
5
1
1
1
2
2
0

Output:

4 3 1 1 1 0 0 0 01.

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1. ↓ - пока такой вариант, потом еще варианты распишу, но думаю, что это самый верный вариант.
'''
def count_occurrences():
    # Инициализация счетчиков для каждой цифры от 1 до 9
    counts = [0] * 9
    # Чтение ввода от пользователя
    while True:
        num = int(input())
        # Проверка завершения последовательности
        if num == 0:
            break
        # Увеличение счетчика для соответствующей цифры
        counts[num - 1] += 1
    # Вывод результатов в нужном формате
    for i in range(9, 0, -1):
        print(f"{counts[i - 1]} - {i}", end=' ')
# Вызов функции для выполнения задачи
count_occurrences()

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Инициализация счетчиков:
'''
counts = [0] * 9
'''
Создается список counts, в котором будут храниться счетчики для каждой цифры от 1 до 9.
Изначально все счетчики устанавливаются в ноль.
'''

'''
Шаг №2. ↓ - Чтение ввода от пользователя:
'''
while True:
    num = int(input())
'''
Запускается бесконечный цикл для чтения ввода от пользователя. Каждое введенное число преобразуется в целое (int).
'''

'''
Шаг №3. ↓ - Проверка завершения последовательности:
'''
    if num == 0:
        break
'''
Если введенное число равно 0, цикл завершается.
'''

'''
Шаг №4. ↓ - Увеличение счетчика для соответствующей цифры:
'''
counts[num - 1] += 1
'''
Для введенной цифры увеличивается соответствующий ей счетчик в списке counts.
'''

'''
Шаг №5. ↓ - Вывод результатов в нужном формате:
'''
for i in range(9, 0, -1):
    print(f"{counts[i - 1]} - {i}", end=' ')
'''
В цикле проходится по списку счетчиков в обратном порядке (от 9 до 1) и выводит количество и соответствующую цифру в 
нужном формате. Формат вывода использует форматированную строку (f-string),
чтобы вставить значения переменных в строку.
'''

'''
Шаг №6. ↓ - Вызов функции:
'''
count_occurrences()
'''
Вызывается сама функция для выполнения задачи.
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓ - Соблюдая строгие условия задачи!=D
'''

def count_occurrences():
    # Инициализация счетчиков для каждой цифры от 1 до 9
    counts = [0] * 9
    # Чтение ввода от пользователя
    while True:
        num = int(input())
        # Проверка завершения последовательности
        if num == 0:
            break
        # Увеличение счетчика для соответствующей цифры
        counts[num - 1] += 1
    # Вывод результатов в нужном формате
    print(*counts, 1)
# Вызов функции для выполнения задачи
count_occurrences()
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Инициализация счетчиков:
'''
counts = [0] * 9
'''
Создаем список counts, где каждый элемент инициализирован нулем. Этот список будет хранить количество вхождений
каждой цифры от 1 до 9.
'''

'''
Шаг №2. ↓ - Чтение ввода от пользователя:
'''
while True:
    num = int(input())
'''
Запускаем бесконечный цикл для чтения чисел от пользователя. Каждое введенное число преобразуется в целое (int).
'''

'''
Шаг №3. ↓ - Проверка завершения последовательности:
'''
if num == 0:
    break
'''
Если введенное число равно 0, завершаем цикл.
'''

'''
Шаг №4. ↓ - Увеличение счетчика для соответствующей цифры:
'''
counts[num - 1] += 1
'''
Увеличиваем счетчик для соответствующей цифры в списке counts.
'''

'''
Шаг №5. ↓ - Вывод результатов в нужном формате:
'''
print(*counts, 1)
'''
Выводим содержимое списка counts, разделяя его элементы пробелами, и добавляем "1" в конец строки
или можно добавить "01." Все ради соблюдения Output.
'''

'''
Шаг №6. ↓ - Вызов функции:
'''
count_occurrences()
'''
Вызываем функцию для выполнения задачи.
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №3. ↓ - Все тоже самое только print другой.
'''

def count_occurrences():
    # Инициализация счетчиков для каждой цифры от 1 до 9
    counts = [0] * 9

    # Чтение ввода от пользователя
    while True:
        num = int(input())  # Читаем число от пользователя

        # Проверка завершения последовательности
        if num == 0:
            break

        # Увеличение счетчика для соответствующей цифры
        counts[num - 1] += 1

    # Вывод результатов в нужном формате
    print(" ".join(map(str, counts)), "01.")


# Вызов функции для выполнения задачи
count_occurrences()
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Инициализация счетчиков:
'''
counts = [0] * 9
'''
Создаем список counts, где каждый элемент инициализирован нулем.
Этот список будет хранить количество вхождений каждой цифры от 1 до 9.
'''

'''
Шаг №2. ↓ - Чтение ввода от пользователя:
'''
while True:
    num = int(input())
'''
Запускаем бесконечный цикл для чтения чисел от пользователя.
Каждое введенное число преобразуется в целое (int).
'''

'''
Шаг №3. ↓ - Проверка завершения последовательности:
'''
if num == 0:
    break
'''
Если введенное число равно 0, завершаем цикл.
'''

'''
Шаг №4. ↓ - Увеличение счетчика для соответствующей цифры:
'''
counts[num - 1] += 1
'''
Увеличиваем счетчик для соответствующей цифры в списке counts.
'''

'''
Шаг №5. ↓ - Вывод результатов в нужном формате:
'''
print(" ".join(map(str, counts)), "01.")

'''
Преобразуем каждый элемент списка counts в строку, объединяем их через пробел с помощью
метода join и добавляем "01." в конец строки.
'''

'''
Шаг №6. ↓ - Вызов функции:
'''
count_occurrences()
'''
Вызываем функцию для выполнения задачи.
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №4. ↓ - Все тоже самое как в Варианте №1.
'''

def count_occurrences():
    # Инициализация счетчиков для каждой цифры от 1 до 9
    counts = [0] * 9
    # Чтение ввода от пользователя
    while True:
        num = int(input())
        # Проверка завершения последовательности
        if num == 0:
            break
        # Увеличение счетчика для соответствующей цифры
        counts[num - 1] += 1
    # Вывод результатов в нужном формате
    for i, count in enumerate(counts, start=1):
        print(f"{count} - {i}", end=". ")
# Вызов функции для выполнения задачи
count_occurrences()
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

'''
Шаг №1. ↓ - Инициализация счетчиков:
'''
counts = [0] * 9
'''
Создаем список counts, где каждый элемент инициализирован нулем.
Этот список будет хранить количество вхождений каждой цифры от 1 до 9.
'''

'''
Шаг №2. ↓ - Чтение ввода от пользователя:
'''
while True:
    num = int(input())
'''
Запускаем бесконечный цикл для чтения чисел от пользователя. 
Каждое введенное число преобразуется в целое (int).
'''

'''
Шаг №3. ↓ - Проверка завершения последовательности:
'''
if num == 0:
    break
'''
Если введенное число равно 0, завершаем цикл.
'''

'''
Шаг №4. ↓ - Увеличение счетчика для соответствующей цифры:
'''
counts[num - 1] += 1
'''
Увеличиваем счетчик для соответствующей цифры в списке counts.
'''

'''
Шаг №5. ↓ - Вывод результатов в нужном формате:
'''
for i, count in enumerate(counts, start=1):
    print(f"{count} - {i}", end=". ")
'''
Используем цикл for для перебора элементов списка counts. enumerate используется для получения итерируемых
пар (индекс, значение). Выводим количество и соответствующую цифру в нужном формате.
'''

'''
Шаг №6. ↓ - Вызов функции:
'''
count_occurrences()
'''
Вызываем функцию для выполнения задачи.
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №2.

Дано: ↓

В программе имеется список из 10 элементов, заполнен случайными числами.
Необходимо найти число, введенное пользователем.
Используйте алгоритм линейного поиска.

Input:
Original list: [7,9,5,6,-99,-32,10,-6,45,14]
Enter a number: -32

Output:
True
Index: 5

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1. ↓ - Где программа предлагает пользователю ввести число, а затем использует функцию linear_search
для поиска этого числа в исходном списке.
Если число найдено, программа выводит True и индекс этого числа в списке.
В противном случае выводится False и -1.
'''
def linear_search(arr, target):
    for i, num in enumerate(arr):
        if num == target:
            return True, i
    return False, -1
# Исходный список
original_list = [7, 9, 5, 6, -99, -32, 10, -6, 45, 14]
# Ввод числа от пользователя
user_number = int(input("Enter a number: "))
# Поиск числа в списке
found, index = linear_search(original_list, user_number)
# Вывод результатов
print(found)
if found:
    print(f"Index: {index}")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Пример ввода/вывода:

Enter a number: -32
True
Index: 5

'''

'''
Шаг №1. ↓ - Определение функции linear_search:
'''
def linear_search(arr, target):
    for i, num in enumerate(arr):
        if num == target:
            return True, i
    return False, -1
'''
linear_search - это функция, которая принимает два аргумента: arr (список, в котором ищем) и target
(число, которое ищем). Используется цикл for, чтобы пройтись по всем элементам списка.
Функция возвращает кортеж (True, i), если число target найдено в списке, где i - индекс этого числа.
Если число не найдено, возвращается (False, -1).
'''

'''
Шаг №2. ↓ - Создание списка и ввод числа от пользователя:
'''
original_list = [7, 9, 5, 6, -99, -32, 10, -6, 45, 14]
user_number = int(input("Enter a number: "))
'''
Создаем список original_list из 10 чисел.
Пользователю предлагается ввести число, и результат сохраняется в переменной user_number.
'''

'''
Шаг №3. ↓ - Поиск числа в списке и вывод результатов:
'''
found, index = linear_search(original_list, user_number)
print(found)
if found:
    print(f"Index: {index}")
'''
Вызываем функцию linear_search с аргументами original_list и user_number.
Результаты (True/False и индекс) сохраняются в переменные found и index.
Выводим результат поиска и, если число найдено (found == True), также выводим индекс числа в списке.
'''

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓ - по сложнее - как мне кажется =D
'''

def linear_search(arr, target):
    for i, num in enumerate(arr):
        if num == target:
            return True, i
    return False, -1
# Исходный список
original_list = [7, 9, 5, 6, -99, -32, 10, -6, 45, 14]
# Ввод числа от пользователя
user_number = int(input("Enter a number: "))
# Поиск числа в списке
found, index = linear_search(original_list, user_number)
# Вывод результатов
print(found)
if found:
    print(f"Index: {index}")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Определение функции поиска:
'''
def linear_search(arr, target):
''''
Эта строка определяет функцию linear_search, принимающую два аргумента: arr (список, в котором ищем) и target
(целевое число, которое мы ищем).
'''''

'''
Шаг №2. ↓ - Итерация по элементам списка:
'''
for i, num in enumerate(arr):
''''
Мы используем цикл for и enumerate для перебора элементов в списке. Переменная i будет содержать индекс элемента,
а num - сам элемент.
'''''

'''
Шаг №3. ↓ - Проверка на равенство:
'''
if num == target:
'''
В этой части кода проверяем, равен ли текущий элемент целевому числу.
'''

'''
Шаг №4. ↓ - Возврат результата, если найдено:
'''
return True, i
'''
Если элемент найден, функция возвращает кортеж (True, i), где True указывает на то, что элемент найден,
а i - индекс этого элемента в списке.
'''

'''
Шаг №5. ↓ - Возврат результата, если не найдено:
'''
return False, -1
'''
Если весь список пройден, и целевой элемент не найден, функция возвращает кортеж (False, -1), где False
указывает на то, что элемент не найден, а -1 - специальное значение для отсутствия индекса.
'''

'''
Шаг №6. ↓ - Исходный список и ввод от пользователя:
'''
original_list = [7, 9, 5, 6, -99, -32, 10, -6, 45, 14]
user_number = int(input("Enter a number: "))
'''
Задается исходный список и запрашивается число от пользователя.
'''

'''
Шаг №7. ↓ - Вызов функции поиска и вывод результатов:
'''
found, index = linear_search(original_list, user_number)
print(found)
if found:
    print(f"Index: {index}")
'''
Функция поиска вызывается с исходным списком и введенным пользователем числом. Результаты выводятся на экран.
Если элемент найден, выводится индекс, в противном случае выводится сообщение об отсутствии элемента.
'''


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Регулярные выражения
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №1.
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Дано: ↓

Напишите программу, в которой необходимо вывести первое слово из строки.

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1. ↓
'''
import re

def first_word_from_string(input_string):
    # Используем регулярное выражение для поиска первого слова
    match = re.match(r"\b\w+\b", input_string)
    if match:
        # Если найдено совпадение, выводим первое слово
        return match.group()
    else:
        # Если не найдено, возвращаем сообщение об отсутствии слова
        return "No word found"
# Пример использования
input_string = "Hello, world! This is a sample string."
result = first_word_from_string(input_string)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля регулярных выражений:
'''
import re
'''
Импортируем модуль re, который предоставляет функционал для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции поиска первого слова из строки:
'''
def first_word_from_string(input_string):
''''
Мы создаем функцию first_word_from_string, которая принимает строку в качестве аргумента.
'''''

'''
Шаг №3. ↓ - Использование регулярного выражения для поиска первого слова:
'''
match = re.match(r"\b\w+\b", input_string)
'''
Здесь мы используем re.match для поиска совпадения с регулярным выражением.
Регулярное выражение r"\b\w+\b" соответствует слову в строке.
'''
'''
\b - граница слова,
\w+ - один или более символов слова (буквы, цифры, символ подчеркивания).
'''
'''
Результат сопоставления сохраняется в переменной match.
'''

'''
Шаг №4. ↓ - Проверка совпадения и возвращение результата:
'''
if match:
    return match.group()
else:
    return "No word found"
'''
Мы проверяем, было ли найдено совпадение.
Если да, возвращаем первое слово, используя match.group().
В противном случае возвращаем сообщение "No word found".
'''

'''
Шаг №5. ↓ - Пример использования функции:
'''
input_string = "Hello, world! This is a sample string."
result = first_word_from_string(input_string)
print(result)
'''
Мы создаем пример строки input_string, вызываем функцию first_word_from_string с этой строкой в качестве аргумента
и выводим результат.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓ - В Python можно использовать более короткие формы для достижения того же результата.
Например, можно воспользоваться тернарным оператором и list comprehension:
'''
import re
def first_word_from_string(input_string):
    return re.match(r"\b\w+\b", input_string).group() if re.match(r"\b\w+\b", input_string) else "No word found"
# Пример использования
input_string = "Hello, world! This is a sample string."
result = first_word_from_string(input_string)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля регулярных выражений:
'''
import re
'''
Этот шаг представляет собой импорт модуля re, который предоставляет функционал для работы с регулярными выражениями
в Python. Модуль re используется для выполнения поиска сопоставлений с регулярными выражениями в тексте.
'''

'''
Шаг №2. ↓ - Определение функции поиска первого слова из строки:
'''
def first_word_from_string(input_string):
''''
На этом шаге мы определяем функцию first_word_from_string, которая принимает в качестве аргумента строку input_string.
Эта функция будет использовать регулярные выражения для поиска первого слова в данной строке.
'''''

'''
Шаг №3. ↓ - Использование регулярного выражения для поиска первого слова:
'''
return re.match(r"\b\w+\b", input_string).group() if re.match(r"\b\w+\b", input_string) else "No word found"
'''
Здесь мы используем регулярное выражение r"\b\w+\b". Разберем его:

\b - граница слова,
\w+ - один или более символов слова (буквы, цифры, символ подчеркивания).
re.match используется для поиска совпадения с начала строки. Если совпадение найдено, мы возвращаем первое слово
с использованием match.group(), иначе возвращаем строку "No word found".
'''

'''
Шаг №4. ↓ - Пример использования функции:
'''
input_string = "Hello, world! This is a sample string."
result = first_word_from_string(input_string)
print(result)
'''
Мы создаем пример строки input_string, затем вызываем функцию first_word_from_string с этой строкой в качестве
аргумента и выводим результат с использованием print(result).
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №3. ↓ - В этом варианте используется re.search вместо re.match. re.search ищет совпадение в любой части строки,
в то время как re.match ищет совпадение только в начале строки. В остальном,
структура кода остается подобной предыдущим вариантам.
'''
import re
def first_word_from_string(input_string):
    match = re.search(r"\b\w+\b", input_string)
    return match.group() if match else "No word found"
# Пример использования
input_string = "Hello, world! This is a sample string."
result = first_word_from_string(input_string)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля регулярных выражений:
'''
import re

'''
Шаг №2. ↓ - Определение функции поиска первого слова из строки:
'''
def first_word_from_string(input_string):
''''
Определяем функцию first_word_from_string, которая принимает в качестве аргумента строку input_string.
''''

'''
Шаг №3. ↓ - Использование регулярного выражения для поиска первого слова:
'''
match = re.search(r"\b\w+\b", input_string)
return match.group() if match else "No word found"
'''
Используем re.search для поиска первого совпадения с регулярным выражением r"\b\w+\b". Здесь:

\b - граница слова,
\w+ - один или более символов слова (буквы, цифры, символ подчеркивания).
Если совпадение найдено, возвращаем первое слово с использованием match.group(), иначе возвращаем строку "No word found".
'''

'''
Шаг №4. ↓ - Пример использования функции:
'''
input_string = "Hello, world! This is a sample string."
result = first_word_from_string(input_string)
print(result)
'''
Создаем строку input_string, вызываем функцию first_word_from_string с этой строкой в качестве аргумента и
выводим результат.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №2.
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Дано: ↓

Напишите программу, которая извлечет дату из строки.

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1. ↓ - Этот код находит и выводит дату в формате "dd.mm.yyyy" из строки, если она там присутствует.
'''
import re
def extract_date_from_string(input_string):
    # Используем регулярное выражение для поиска даты
    match = re.search(r'\b\d{1,2}\.\d{1,2}\.\d{4}\b', input_string)
    if match:
        # Если найдено совпадение, выводим дату
        return match.group()
    else:
        # Если не найдено, возвращаем сообщение об отсутствии даты
        return "No date found"
# Пример использования
input_string = "The event will take place on 25.12.2023. Don't miss it!"
result = extract_date_from_string(input_string)
print(result)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля регулярных выражений:
'''
import re
'''
Мы импортируем модуль re для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции извлечения даты из строки:
'''
def extract_date_from_string(input_string):
''''
Определяем функцию extract_date_from_string, которая принимает в качестве аргумента строку input_string.
'''''

'''
Шаг №3. ↓ - Использование регулярного выражения для поиска даты:
'''
match = re.search(r'\b\d{1,2}\.\d{1,2}\.\d{4}\b', input_string)
'''
Используем re.search для поиска совпадения с регулярным выражением. Регулярное
выражение r'\b\d{1,2}\.\d{1,2}\.\d{4}\b' означает:

\d{1,2} - одна или две цифры для дня и месяца,
\. - точка в качестве разделителя,
\d{4} - четыре цифры для года.
Также используется \b для границы слова.
'''

'''
Шаг №4. ↓ - Проверка совпадения и возвращение результата:
'''
if match:
    return match.group()
else:
    return "No date found"
'''
Мы проверяем, было ли найдено совпадение. Если да, возвращаем найденную дату с использованием match.group(),
иначе возвращаем строку "No date found".
'''

'''
Шаг №5. ↓ - Пример использования функции:
'''
input_string = "The event will take place on 25.12.2023. Don't miss it!"
result = extract_date_from_string(input_string)
print(result)
'''
Создаем строку input_string, вызываем функцию extract_date_from_string с этой строкой в качестве аргумента
и выводим результат с использованием print(result).
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓ - Мы также можем написать более компактный и лаконичный код с использованием некоторых возможностей Python.
'''
import re
def extract_date_from_string(input_string):
    match = re.search(r'\b\d{1,2}\.\d{1,2}\.\d{4}\b', input_string)
    return match.group() if match else "No date found"
# Пример использования
input_string = "The event will take place on 25.12.2023. Don't miss it!"
print(extract_date_from_string(input_string))
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля регулярных выражений:
Этот шаг представляет собой импорт модуля re, который предоставляет функционал для работы
с регулярными выражениями в Python.
'''
import re

'''
Шаг №2. ↓ - Определение функции извлечения даты из строки:
На этом этапе определяется функция extract_date_from_string, которая принимает строку input_string
в качестве аргумента.
'''
def extract_date_from_string(input_string):

''''
Шаг №3. ↓ - Использование регулярного выражения для поиска даты:

В этой строке кода используется re.search для поиска совпадения с регулярным выражением
r'\b\d{1,2}\.\d{1,2}\.\d{4}\b'. Это регулярное выражение ищет соответствие шаблону "dd.mm.yyyy".

\b - граница слова,
\d{1,2} - одна или две цифры для дня и месяца,
\. - точка в качестве разделителя,
\d{4} - четыре цифры для года.

'''''
match = re.search(r'\b\d{1,2}\.\d{1,2}\.\d{4}\b', input_string)

'''
Шаг №4. ↓ - Возвращение результата:
В этой строке используется тернарный оператор для возврата найденной даты (match.group()) в случае успешного поиска,
иначе возвращается строка "No date found".
'''
return match.group() if match else "No date found"

'''
Шаг №5. ↓ - Пример использования функции:
Создается строка input_string, затем вызывается функция extract_date_from_string с этой строкой в качестве аргумента.
Результат выводится с использованием print.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №3. ↓ - Мы можем сократить код, используя lambda-функцию и re.findall для более краткой записи:
'''
import re
extract_date_from_string = lambda s: re.findall(r'\b\d{1,2}\.\d{1,2}\.\d{4}\b', s) or ["No date found"]
input_string = "The event will take place on 25.12.2023. Don't miss it!"
print(*extract_date_from_string(input_string))
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт модуля регулярных выражений:
'''
import re

'''
Шаг №2. ↓ - Определение lambda-функции извлечения даты из строки:
'''
extract_date_from_string = lambda s: re.findall(r'\b\d{1,2}\.\d{1,2}\.\d{4}\b', s) or ["No date found"]
'''
Определяем lambda-функцию extract_date_from_string, которая принимает строку s.
Внутри lambda-функции используется re.findall для поиска всех совпадений с регулярным выражением.
'''

'''
Шаг №3. ↓ - Пример использования lambda-функции:
'''
input_string = "The event will take place on 25.12.2023. Don't miss it!"
print(*extract_date_from_string(input_string))
'''
Создаем строку input_string и вызываем lambda-функцию extract_date_from_string с этой строкой в качестве аргумента.
Результат передается в print с использованием * для распаковки списка.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №3.
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Дано: ↓

Напишите программу, в которой я ввожу телефонный номер. Необходимо проверить правильность формата телефонного номера.

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №1. ↓ 
'''
import re
def check_phone_number(phone_number):
    # Убираем все нецифровые символы из номера
    cleaned_number = re.sub(r'\D', '', phone_number)
    # Проверяем, что длина номера равна 11
    if len(cleaned_number) == 11:
        print(f"Номер {phone_number} введен в правильном формате.")
    else:
        print(f"Номер {phone_number} введен в неправильном формате.")
# Пример использования
user_input = input("Введите телефонный номер: ")
check_phone_number(user_input)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Здесь мы импортируем модуль re (регулярные выражения),
который позволяет работать с регулярными выражениями в Python.
'''
import re

'''
Шаг №2. ↓ - Мы определяем функцию check_phone_number,
которая принимает в качестве аргумента введенный телефонный номер.
'''
def check_phone_number(phone_number):

''''
Шаг №3. ↓ - С использованием re.sub мы убираем все нецифровые символы из введенного номера
(\D - это регулярное выражение для любого нецифрового символа).
'''''
cleaned_number = re.sub(r'\D', '', phone_number)

'''
Шаг №4. ↓ - Мы проверяем, что длина очищенного номера равна 11 символам.
'''
if len(cleaned_number) == 11:

'''
Шаг №5. ↓ - Здесь мы запрашиваем у пользователя ввод телефонного номера, а затем вызываем функцию check_phone_number,
передавая введенный номер в качестве аргумента.
'''
print(f"Номер {phone_number} введен в правильном формате.")
else:
print(f"Номер {phone_number} введен в неправильном формате.")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓ 
'''
def check_phone_number(phone_number):
    # Убираем все нецифровые символы из номера
    cleaned_number = ''.join(filter(str.isdigit, phone_number))
    # Проверяем, что длина номера равна 10
    if len(cleaned_number) == 10:
        print(f"Номер {phone_number} введен в правильном формате.")
    else:
        print(f"Номер {phone_number} введен в неправильном формате.")
# Пример использования
user_input = input("Введите телефонный номер: ")
check_phone_number(user_input)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импортирование модуля re:
'''
import re
'''
Шаг №2. ↓ - Определение функции проверки номера:
'''
def check_phone_number(phone_number):
''''
Шаг №3. ↓ - Очистка номера от нецифровых символов с использованием регулярного выражения:
'''''
cleaned_number = re.sub(r'\D', '', phone_number)
'''
Шаг №4. ↓ - Проверка длины очищенного номера:
'''
if len(cleaned_number) == 11:
'''
Шаг №5. ↓ - Вывод сообщения о правильном или неправильном формате:
'''
print(f"Номер {phone_number} введен в правильном формате.")
else:
print(f"Номер {phone_number} введен в неправильном формате.")
'''
Шаг №6. ↓ - Запрос ввода номера у пользователя:
'''
user_input = input("Введите телефонный номер: ")
'''
Шаг №7. ↓ - Вызов функции проверки номера с введенным значением:
'''
check_phone_number(user_input)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №3. ↓ 
'''
import re
def validate_phone_number(phone_number):
    # Паттерн для распознавания телефонных номеров
    pattern = re.compile(r'^(\+\d{1,2})?[-.\s]?(\(?(\d{3})\)?)[-.\s]?(\d{3})[-.\s]?(\d{2})[-.\s]?(\d{2})$')
    # Проверка соответствия номера паттерну
    match = pattern.match(phone_number)
    # Вывод результата
    if match:
        print(f"Номер '{phone_number}' правильный.")
        print("Страна:", match.group(1))
        print("Код региона:", match.group(3))
        print("Первые три цифры:", match.group(4))
        print("Следующие две цифры:", match.group(5))
        print("Последние две цифры:", match.group(6))
    else:
        print(f"Номер '{phone_number}' неправильный.")
# Список телефонных номеров для проверки
phone_numbers = [
    "+71234567890",
    "81234567890",
    "+7(123)4567890",
    "8(123)4567890",
    "+7 - (123) - 456 - 78 - 90",
    "8 - (123) - 456 - 78 - 90",
    "+7-123-456-78-90",
    "8-123-456-78-90",
    "+7-123-4567890",
    "8-123-4567890",
    "+7-(123)-456-78-90",
    "8-(123)-456-78-90",
    "+7(123)-456-7890",
    "8(123)-456-7890",
    "+7 (123) 456 78 90",
    "8 (123) 456 78 90",
    "+ 7 - 123 - 456 - 78 - 90",
    "8 - 123 - 456 - 78 - 90",
    "+7(123)456-7890",
    "8(123)456-7890",
    "+7-(123)456-78-90",
    "8-(123)456-78-90",
    "+7(123) - 4567 - 890",
    "8(123) - 4567 - 890",
    "+7 - (123) - 4567 - 890",
    "8 - (123) - 4567 - 890",
    "+7 - 123 - 4567 - 890",
    "8 - 123 - 4567 - 890",
    "+7-123-4567-890",
    "8-123-4567-890",
    "+7(123)-4567-890",
    "8(123)-4567-890",
    "+7123-45678-90",
    "8123-45678-90",
    "+7(123)45678-90",
    "8(123)45678-90",
    "+7-123-45678-90",
    "8-123-45678-90",
    "+7 - 123 - 45678 - 90",
    "8 - 123 - 45678 - 90",
    "+7-(123)-45-67-890",
    "8-(123)-45-67-890",
    "+7(123)45 67 890",
    "8(123)45 67 890",
    "+7 - (123) - 45 - 67 - 890",
    "8 - (123) - 45 -67 - 890",
    "+7 - 123 - 45 -67 - 890",
    "8 - 123 - 45 - 67 - 890",
    "+7(123)-4567-890",
    "8(123)-4567-890"
]
# Проверка каждого номера
for number in phone_numbers:
    validate_phone_number(number)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт библиотеки re: 
'''
import re
'''
Эта строка добавляет модуль re, который предоставляет функциональность для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции validate_phone_number:
'''
def validate_phone_number(phone_number):
''''
Эта функция принимает на вход строку с телефонным номером phone_number.
''''

'''
Шаг №3. ↓ - Определение регулярного выражения pattern:
'''
pattern = re.compile(r'^(\+\d{1,2})?[-.\s]?(\(?(\d{3})\)?)[-.\s]?(\d{3})[-.\s]?(\d{2})[-.\s]?(\d{2})$')
'''
Это регулярное выражение разбито на следующие группы:

(\+\d{1,2})?: Ноль или один символ "+" (возможно с одной или двумя цифрами после него).
[-.\s]?: Ноль или один символ из множества "-", ".", или пробела.
(\(?(\d{3})\)?): Три цифры, возможно заключенные в скобки.
(\d{3}): Три цифры.
[-.\s]?: Ноль или один символ из множества "-", ".", или пробела.
(\d{2}): Две цифры.
[-.\s]?: Ноль или один символ из множества "-", ".", или пробела.
(\d{2}): Две цифры.
'''

'''
Шаг №4. ↓ - Проверка соответствия номера паттерну:
'''
match = pattern.match(phone_number)
'''
Эта строка использует метод match объекта pattern, чтобы проверить, соответствует ли переданный номер
регулярному выражению.
'''

'''
Шаг №5. ↓ - Вывод результата:
'''
if match:
    print(f"Номер '{phone_number}' правильный.")
    print("Группы:")
    print("Страна:", match.group(1))
    print("Код региона:", match.group(3))
    print("Первые три цифры:", match.group(4))
    print("Следующие две цифры:", match.group(5))
    print("Последние две цифры:", match.group(6))
else:
    print(f"Номер '{phone_number}' неправильный.")
'''
Если номер соответствует регулярному выражению, выводятся группы, соответствующие различным частям номера
(код страны, код региона и т.д.). В противном случае выводится сообщение о том, что номер неправильный.
'''

'''
Шаг №6. ↓ - Список телефонных номеров для проверки:
'''
phone_numbers = [
    # ... (ваш список номеров)
]
'''
Здесь вы создаете список телефонных номеров для проверки.
'''

'''
Шаг №7. ↓ - Проверка каждого номера:
'''
for number in phone_numbers:
    validate_phone_number(number)
'''
В этом цикле каждый номер из списка передается в функцию validate_phone_number для проверки.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №3+1. ↓ 
'''
import re

def validate_phone_number(phone_number):
    # Паттерн для распознавания телефонных номеров
    pattern = re.compile(r'^(\+\d{1,2})?[-.\s]?(\(?(\d{3})\)?)[-.\s]?(\d{3})[-.\s]?(\d{2})[-.\s]?(\d{2})$')

    # Проверка соответствия номера паттерну
    match = pattern.match(phone_number)

    # Вывод результата
    if match:
        print(f"Номер '{phone_number}' правильный.")
        print("Страна:", match.group(1))
        print("Код региона:", match.group(3))
        print("Первые три цифры:", match.group(4))
        print("Следующие две цифры:", match.group(5))
        print("Последние две цифры:", match.group(6))
    else:
        print(f"Номер '{phone_number}' неправильный.")

# Список телефонных номеров для проверки
phone_numbers = [
    # ... (ваш список номеров)
]

# Пользовательский ввод и проверка
while True:
    user_input = input("Введите номер телефона (или 'exit' для завершения): ")

    if user_input.lower() == 'exit':
        break

    validate_phone_number(user_input)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт библиотеки re: 
'''
import re
'''
Эта строка добавляет модуль re, который предоставляет функциональность для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции validate_phone_number:
'''
def validate_phone_number(phone_number):
''''
Эта функция принимает на вход строку с телефонным номером phone_number.
''''

'''
Шаг №3. ↓ - Определение регулярного выражения pattern:
'''
pattern = re.compile(r'^(\+\d{1,2})?[-.\s]?(\(?(\d{3})\)?)[-.\s]?(\d{3})[-.\s]?(\d{2})[-.\s]?(\d{2})$')
'''
Это регулярное выражение разбито на несколько групп, каждая из которых соответствует части телефонного номера
(код страны, код региона и т.д.).
'''

'''
Шаг №4. ↓ - Проверка соответствия номера паттерну:
'''
match = pattern.match(phone_number)
'''
Эта строка использует метод match объекта pattern, чтобы проверить, соответствует ли переданный номер
регулярному выражению.
'''

'''
Шаг №5. ↓ - Вывод результата:
'''
if match:
    print(f"Номер '{phone_number}' правильный.")
    print("Страна:", match.group(1))
    print("Код региона:", match.group(3))
    print("Первые три цифры:", match.group(4))
    print("Следующие две цифры:", match.group(5))
    print("Последние две цифры:", match.group(6))
else:
    print(f"Номер '{phone_number}' неправильный.")
'''
Если номер соответствует регулярному выражению, программа выводит информацию о различных частях номера
(код страны, код региона и т.д.). В противном случае выводится сообщение о том, что номер неправильный.
'''

'''
Шаг №6. ↓ - Список телефонных номеров для проверки:
'''
phone_numbers = [
    # ... (ваш список номеров)
]
'''
Здесь создается список телефонных номеров для проверки.
В реальном применении этот список может быть заменен на вашу базу данных номеров.
'''


'''
Шаг №7. ↓ - Пользовательский ввод и проверка:
'''
while True:
    user_input = input("Введите номер телефона (или 'exit' для завершения): ")

    if user_input.lower() == 'exit':
        break

    validate_phone_number(user_input)

'''
В этой части кода создается бесконечный цикл while, который просит пользователя ввести номер телефона.
Если пользователь вводит "exit", программа завершается. 
В противном случае введенный номер телефона передается для проверки в функцию validate_phone_number.
Этот процесс повторяется до тех пор, пока пользователь не решит завершить программу.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №4.
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Дано: ↓

Напишите программу, в которой извлекается информация из html-файла.

Решение:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
!!! - Внимание - !!!
Обработка HTML-файлов с использованием регулярных выражений может быть не самым рекомендуемым способом,
так как HTML является структурированным языком и лучше всего обрабатывается с использованием парсеров HTML.
Но если мой (Ваш) код HTML прост и не содержит сложной вложенной структуры, вы можете использовать регулярные выражения
для извлечения информации.

Вариант №1. ↓  - Вот пример одного из вариантов программы на Python,
которая использует регулярные выражения для извлечения содержимого тега <title> из HTML-файла:
'''
import re

def extract_title_from_html(html_content):
    # Регулярное выражение для извлечения содержимого тега <title>
    title_pattern = re.compile(r'<title>(.*?)<\/title>', re.DOTALL)

    # Ищем соответствие регулярному выражению
    match = title_pattern.search(html_content)

    # Выводим результат
    if match:
        print("Заголовок страницы:", match.group(1))
    else:
        print("Заголовок не найден.")

# Пример HTML-файла
html_content = """
<html>
<head>
    <title>Пример HTML-файла</title>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это пример HTML-файла.</p>
</body>
</html>
"""

# Извлекаем заголовок
extract_title_from_html(html_content)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт библиотеки re:
'''
import re
'''
Эта строка добавляет модуль re, который предоставляет функциональность для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции extract_title_from_html:
'''
def extract_title_from_html(html_content):
''''
Эта функция принимает на вход строку с HTML-кодом html_content.
''''

'''
Шаг №3. ↓ - Определение регулярного выражения title_pattern:
'''
title_pattern = re.compile(r'<title>(.*?)<\/title>', re.DOTALL)
'''
Это регулярное выражение ищет открывающий тег <title>, затем любое количество символов в режиме "ленивого" 
сопоставления (.*?), и, наконец, закрывающий тег <\/title>. Флаг re.DOTALL позволяет точке (.) сопоставляться с 
символами новой строки.
'''

'''
Шаг №4. ↓ - Поиск соответствия регулярному выражению:
'''
match = title_pattern.search(html_content)
'''
Эта строка использует метод search объекта title_pattern, чтобы найти первое соответствие регулярному выражению внутри
строки html_content.
'''

'''
Шаг №5. ↓ - Вывод результата:
'''
if match:
    print("Заголовок страницы:", match.group(1))
else:
    print("Заголовок не найден.")
'''
Если соответствие найдено (match не является None), программа выводит содержимое первой группы регулярного
выражения, т.е., содержимое тега <title>. В противном случае выводится сообщение о том, что заголовок не найден.
'''

'''
Шаг №6. ↓ - Пример HTML-файла:
'''
'''

html_content = """
<html>
<head>
    <title>Пример HTML-файла</title>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это пример HTML-файла.</p>
</body>
</html>

'''
'''
В этом примере определен HTML-файл, в котором есть тег <title> с текстом "Пример HTML-файла".
'''

'''
Шаг №7. ↓ - Извлечение заголовка:
'''
extract_title_from_html(html_content)
'''
Этот код вызывает функцию extract_title_from_html с примером HTML-файла в качестве аргумента,
что приводит к выполнению поиска заголовка и его вывода.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №2. ↓ - Добавим ещё один пример для демонстрации обработки HTML с использованием регулярных выражений.
В этот раз мы уже будем извлекать содержимое тега <p>.
'''
import re

def extract_paragraphs_from_html(html_content):
    # Регулярное выражение для извлечения содержимого тега <p>
    paragraph_pattern = re.compile(r'<p>(.*?)<\/p>', re.DOTALL)

    # Ищем соответствие регулярному выражению
    matches = paragraph_pattern.findall(html_content)

    # Выводим результат
    if matches:
        print("Абзацы:")
        for match in matches:
            print("- ", match.strip())
    else:
        print("Абзацы не найдены.")

# Пример HTML-файла с несколькими абзацами
html_content_with_paragraphs = """
<html>
<head>
    <title>Пример HTML-файла</title>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это пример HTML-файла с несколькими абзацами.</p>
    <p>Второй абзац.</p>
    <p>И ещё один абзац.</p>
</body>
</html>
"""

# Извлекаем абзацы
extract_paragraphs_from_html(html_content_with_paragraphs)

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Снова импорт библиотеки re: 
'''
import re
'''
Эта строка добавляет модуль re, который предоставляет функциональность для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Определение функции extract_paragraphs_from_html:
'''
def extract_paragraphs_from_html(html_content):
''''
Эта функция принимает на вход строку с HTML-кодом html_content.
''''

'''
Шаг №3. ↓ - Определение регулярного выражения paragraph_pattern:
'''
paragraph_pattern = re.compile(r'<p>(.*?)<\/p>', re.DOTALL)
'''
Это регулярное выражение ищет открывающий тег <p>, затем любое количество символов в режиме "ленивого"
сопоставления (.*?), и, наконец, закрывающий тег <\/p>. Флаг re.DOTALL позволяет точке (.) сопоставляться с символами
новой строки.
'''

'''
Шаг №4. ↓ - Поиск соответствия регулярному выражению:
'''
matches = paragraph_pattern.findall(html_content)
'''
Эта строка использует метод findall объекта paragraph_pattern, чтобы найти все соответствия регулярному
выражению внутри строки html_content.
'''

'''
Шаг №5. ↓ - Вывод результата:
'''
if matches:
    print("Абзацы:")
    for match in matches:
        print("- ", match.strip())
else:
    print("Абзацы не найдены.")
'''
Если соответствия найдены (matches не пуст), программа выводит содержимое каждого абзаца,
очищая его от лишних пробелов с помощью strip(). В противном случае выводится сообщение о том, что абзацы не найдены.
'''

'''
Шаг №6. ↓ - Пример HTML-файла с несколькими абзацами:
'''
'''

html_content_with_paragraphs = """
<html>
<head>
    <title>Пример HTML-файла</title>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это пример HTML-файла с несколькими абзацами.</p>
    <p>Второй абзац.</p>
    <p>И ещё один абзац.</p>
</body>
</html>

'''
'''
В этом примере определен HTML-файл, в котором есть несколько тегов <p> с текстом абзацев.
'''

'''
Шаг №7. ↓ - Извлечение абзацев:
'''
extract_paragraphs_from_html(html_content_with_paragraphs)
'''
Этот код вызывает функцию extract_paragraphs_from_html с примером HTML-файла в качестве аргумента, что приводит
к выполнению поиска абзацев и их вывода.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Вариант №3. ↓ - Можно сделать код более кратким, используя тернарный оператор.
'''
import re
def extract_paragraphs_from_html(html_content):
    paragraph_pattern = re.compile(r'<p>(.*?)<\/p>', re.DOTALL)
    matches = paragraph_pattern.findall(html_content)
    print("Абзацы:" if matches else "Абзацы не найдены.", *[f"- {match.strip()}" for match in matches])
html_content_with_paragraphs = """
<html>
<head>
    <title>Пример HTML-файла</title>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это пример HTML-файла с несколькими абзацами.</p>
    <p>Второй абзац.</p>
    <p>И ещё один абзац.</p>
</body>
</html>
"""
extract_paragraphs_from_html(html_content_with_paragraphs)
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Шаг №1. ↓ - Импорт библиотеки re: 
'''
import re
'''
Эта строка добавляет модуль re, который предоставляет функциональность для работы с регулярными выражениями в Python.
'''

'''
Шаг №2. ↓ - Импорт библиотеки re: 
'''
def extract_paragraphs_from_html(html_content):
''''
Эта функция принимает на вход строку с HTML-кодом html_content.
''''

'''
Шаг №3. ↓ - Определение регулярного выражения paragraph_pattern:
'''
paragraph_pattern = re.compile(r'<p>(.*?)<\/p>', re.DOTALL)
'''
Это регулярное выражение ищет открывающий тег <p>, затем любое количество символов в режиме "ленивого" сопоставления
(.*?), и, наконец, закрывающий тег <\/p>. Флаг re.DOTALL позволяет точке (.) сопоставляться с символами новой строки.
'''

'''
Шаг №4. ↓ - Поиск соответствия регулярному выражению:
'''
matches = paragraph_pattern.findall(html_content)
'''
Эта строка использует метод findall объекта paragraph_pattern, чтобы найти все соответствия регулярному
выражению внутри строки html_content.
'''

'''
Шаг №5. ↓ - Вывод результата:
'''
print("Абзацы:" if matches else "Абзацы не найдены.", *[f"- {match.strip()}" for match in matches])
'''
Сначала используется тернарный оператор if matches else, чтобы определить, были ли найдены абзацы.
Затем, если абзацы найдены, используется list comprehension ([f"- {match.strip()}" for match in matches])
для формирования списка строк с содержимым каждого абзаца, при этом убираются лишние пробелы вокруг
текста абзаца с помощью strip().
Весь результат выводится с использованием функции print.
'''

'''
Шаг №6. ↓ - Пример HTML-файла с несколькими абзацами:
'''
'''
html_content_with_paragraphs = """
<html>
<head>
    <title>Пример HTML-файла</title>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это пример HTML-файла с несколькими абзацами.</p>
    <p>Второй абзац.</p>
    <p>И ещё один абзац.</p>
</body>
</html>
'''
'''
В этом примере определен HTML-файл, в котором есть несколько тегов <p> с текстом абзацев.
'''

'''
Шаг №7. ↓ - Извлечение абзацев:
'''
extract_paragraphs_from_html(html_content_with_paragraphs)
'''
Этот код вызывает функцию extract_paragraphs_from_html с примером HTML-файла в качестве аргумента,
что приводит к выполнению поиска абзацев и их вывода.
'''
