# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Дата: 22-23 ноября 2023

# Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
# Дисциплина: Основы программирования на Python

# Урок №8 - от 22.11.2023 - Практическая работа № 7 Функции. Модули, библиотеки и паке ты

# Выполните следующие задания: ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Написать лямбду-функцию, которая:
# 1. добавляет 15 к заданному числу, переданному в качестве аргумента;
# Input: 10 Output:25
# 2. умножает аргумент x на аргумент y, выведите результат;
# Input: 12 4 Output:48
# 3. фильтрует список целых чисел, заданных пользователем;
# Список целых чисел:
# [78, 2, 13, 46, 5, 61, 74, 81, 94, 10]
# Список четных чисел:
# [78, 2, 46, 74, 94, 10]
# Список нечетных чисел:
# [13, 5, 61, 81]
# 4.выводит год, месяц, дату и время.
# При решении используйте модуль datetime. Output:
# 2022-07-19 07:58:31.246609
# 2022
# 7
# 19
# 07:58:31.246609

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓ (Самого задания)
# Задание №1. Пункт №1. - добавляет 15 к заданному числу, переданному в качестве аргумента; Input: 10 Output:25
# Вариант №1. (Решение данного пункта в задании) ↓

# Лямбда-функция, добавляющая 15 к заданному числу
add_15 = lambda x: x + 15
# Пример использования
input_number = 10
output_result = add_15(input_number)
print("Input:", input_number, "Output:", output_result)

# Шаг за шагом (как я понял):

# Шаг №1. - Определение лямбда-функции:
# Используем ключевое слово lambda.
# Указываем аргумент функции (в данном случае, x).
# Указываем тело функции: x + 15.

# Вок как это можно записать:
add_15 = lambda x: x + 15
# Теперь add_15 представляет собой лямбда-функцию, которая прибавляет 15 к переданному аргументу x.

# Шаг №2. - Использование лямбда-функции:
# Передаем число в лямбда-функцию, чтобы получить результат.
# В примере ниже, мы используем число 10:
input_number = 10
output_result = add_15(input_number)

# Шаг №3. - Вывод результата:
# Выводим результат с использованием функции print:
print("Input:", input_number, "Output:", output_result)

# При запуске этого кода вы увидите, что вводное число (input_number) равно 10, и результат (output_result) равен 25.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. ↓ # Пункт №1. - добавляет 15 к заданному числу, переданному в качестве аргумента; Input: 10 Output:25
# Вариант №2. (Решение данного пункта в задании) ↓

from functools import partial

# Частичное применение оператора сложения с аргументом 15
add_15_partial = partial(lambda x, y: x + y, 15)
# Пример использования
input_number = 10
output_result = add_15_partial(input_number)
# Вывод результата
print("Input:", input_number, "Output:", output_result)

# Шаг за шагом (как я понял):

# Шаг №1. - Импортируем functools.partial:
from functools import partial

# Шаг за шагом (как я понял):

# Шаг №2. - Создаем частичную функцию:
# Используем partial, чтобы частично применить лямбда-функцию (в данном случае, сложение) и передать значение 15
# в качестве второго аргумента.
add_15_partial = partial(lambda x, y: x + y, 15)

# Шаг №3. - Применяем функцию:
# Передаем число (input_number) в частично примененную функцию add_15_partial.
input_number = 10
output_result = add_15_partial(input_number)

# Шаг №4. - Выводим результат:
# Используем print, чтобы вывести входное число и результат сложения.
print("Input:", input_number, "Output:", output_result)


# Получается, мы используем functools.partial для создания новой функции (add_15_partial),
# которая уже частично применила оператор сложения с аргументом 15. Затем мы передаем число в эту частично примененную
# функцию и выводим результат. Результат будет равен сумме входного числа и 15 (в данном случае, 10 + 15 = 25).

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №1. - добавляет 15 к заданному числу, переданному в качестве аргумента; Input: 10 Output:25
# Вариант №3. (Решение данного пункта в задании) ↓

# Именованная функция, добавляющая 15 к заданному числу
def add_15_function(x):
    return x + 15
# Пример использования
input_number = 10
output_result = add_15_function(input_number)
# Вывод результата
print("Input:", input_number, "Output:", output_result)

# Шаг за шагом (как я понял):

# Шаг №1. - Определение именованной функции:
# Используем ключевое слово def для определения функции, затем называем функцию add_15_function (вообще можно как
# угодно обзывать функции), после обязательно указываем аргумент x - и уже в теле функции - мы выполняем операцию (как
# Доктор Стивен Стрендж) сложения x + 15 и вуаля!
def add_15_function(x):
    return x + 15

# Шаг №2. - Пример использования функции:
# Далее, создаем переменную input_number и присваиваем ей значение 10.
input_number = 10
# Вызываем функцию add_15_function, передавая в нее input_number.
output_result = add_15_function(input_number)

# Шаг №3. - Вывод результата:
# Используем оператор print для вывода входного числа и результата.
print("Input:", input_number, "Output:", output_result)
# В конечном итоге, код создает функцию add_15_function, которая принимает аргумент x и возвращает сумму x + 15.
# Затем мы используем эту функцию, передавая ей входное число 10, и выводим результат с использованием print.
# Результат будет равен 25 (10 + 15).

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №2. - умножает аргумент x на аргумент y, выведите результат; Input: 12 4 Output:48
# Вариант №1. (Решение данного пункта в задании) ↓

# Лямбда-функция для умножения двух чисел
multiply = lambda x, y: x * y
# Пример использования
input_x, input_y = 12, 4
output_result = multiply(input_x, input_y)
# Вывод результата
print("Input:", input_x, input_y, "Output:", output_result)

# И так, шаг за шагом давайте посмотрим что к чему:

# Шаг №1. - Определение лямбда-функции:
# Используем ключевое слово lambda.
# Указываем аргументы x и y.
# Указываем тело функции: x * y.
multiply = lambda x, y: x * y

# Шаг №2. - Пример использования функции:
# Создаем переменные input_x и input_y и присваиваем им значения 12 и 4 соответственно.
input_x, input_y = 12, 4
# Вызываем лямбда-функцию multiply, передавая ей input_x и input_y.
output_result = multiply(input_x, input_y)

# Шаг №3. - Вывод результата:
# Используем оператор print для вывода входных чисел и результата умножения.
print("Input:", input_x, input_y, "Output:", output_result)
# После выполнения этого кода, мы увидим, что входные числа (input_x и input_y) равны 12 и 4 соответственно,
# а результат (output_result) равен 48 (12 * 4).

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №2. - умножает аргумент x на аргумент y, выведите результат; Input: 12 4 Output:48
# Вариант №2. (Решение данного пункта в задании) ↓

# Лямбда-функция для умножения двух чисел
multiply = lambda x, y: x * y
# Пример использования с map
input_x, input_y = 12, 4
output_result = list(map(lambda x, y: x * y, [input_x], [input_y]))[0]
# Вывод результата
print("Input:", input_x, input_y, "Output:", output_result)

# А вот тут давайте уже по подробнее:

# Шаг №1. - Определение лямбда-функции:
# Используем ключевое слово lambda.
# Указываем аргументы x и y.
# Указываем тело функции: x * y.
multiply = lambda x, y: x * y

# Шаг №2. - Пример использования с map:
# Создаем переменные input_x и input_y и присваиваем им значения 12 и 4 соответственно.
input_x, input_y = 12, 4
# Используем функцию map для применения лямбда-функции ко всем элементам списков [input_x] и [input_y].
mapped_results = map(lambda x, y: x * y, [input_x], [input_y])

# Шаг №3. - Преобразование результатов map в список:
# С помощью list преобразуем результаты map в список.
result_list = list(mapped_results)

# Шаг №4. - Извлечение результата из списка:
# Берем первый (и единственный) элемент списка с помощью индекса [0].
output_result = result_list[0]

# Шаг №5. - Вывод результата:
# Используем оператор print для вывода входных чисел и результата умножения.
print("Input:", input_x, input_y, "Output:", output_result)

# И так, обращаем внимание, что использование map и list в данном контексте может быть излишним (но "понтанутся" можно)
# в этом конкретном примере, и прямое использование лямбда-функции вполне подходит для задачи умножения двух чисел.
# Однако этот пример демонстрирует принципы работы с функциями высшего порядка и функциональными возможностями Python.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №2. - умножает аргумент x на аргумент y, выведите результат; Input: 12 4 Output:48
# Вариант №3. (Решение данного пункта в задании) ↓

# Можно также, рассмотреть еще один вариант (последний), используя возможности библиотеки operator.
# Эта библиотека предоставляет функции, эквивалентные стандартным операторам, и может быть полезной вместе с функциями
# высшего порядка, такими как map.

from operator import mul
# Пример использования с map и operator.mul
input_x, input_y = 12, 4
output_result = list(map(mul, [input_x], [input_y]))[0]
# Вывод результата
print("Input:", input_x, input_y, "Output:", output_result)

# Шаг №1. - Импорт функции mul из библиотеки operator:
from operator import mul
# Этот шаг позволяет нам использовать функцию умножения mul из библиотеки operator вместо
# явного использования лямбда-функции.

# Шаг №2. - Пример использования с map и operator.mul:
# Создаем переменные input_x и input_y и присваиваем им значения 12 и 4 соответственно.
input_x, input_y = 12, 4
# Используем функцию map для применения mul к парам значений из списков [input_x] и [input_y].
mapped_results = map(mul, [input_x], [input_y])

# Шаг №3. - Преобразование результатов map в список:
# С помощью list преобразуем результаты map в список.
result_list = list(mapped_results)

# Шаг №4. - Извлечение результата из списка:
# Берем первый (и единственный) элемент списка с помощью индекса [0].
output_result = result_list[0]

# Шаг №5. - Вывод результата:
# Используем оператор print для вывода входных чисел и результата умножения.
print("Input:", input_x, input_y, "Output:", output_result)

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №3. - фильтрует список целых чисел, заданных пользователем;
# Список целых чисел: [78, 2, 13, 46, 5, 61, 74, 81, 94, 10]
# Список четных чисел: [78, 2, 46, 74, 94, 10]
# Список нечетных чисел: [13, 5, 61, 81]
# Вариант №1. (Решение данного пункта в задании) ↓

# Получение списка целых чисел от пользователя
user_numbers = list(map(int, input("Введите список целых чисел, разделенных пробелами: ").split()))
# Лямбда-функция для фильтрации четных чисел
filter_even = lambda x: x % 2 == 0
# Лямбда-функция для фильтрации нечетных чисел
filter_odd = lambda x: x % 2 != 0
# Фильтрация и вывод результатов
even_numbers = list(filter(filter_even, user_numbers))
odd_numbers = list(filter(filter_odd, user_numbers))
print("Список четных чисел:", even_numbers)
print("Список нечетных чисел:", odd_numbers)

# Теперь шаг за шагом:
# Шаг №1. - Получение списка целых чисел от пользователя:
# Мы используем функцию input, чтобы запросить у пользователя ввод целых чисел, разделенных пробелами.
# input() возвращает строку, которую мы разбиваем с помощью метода split().
# С помощью map(int, ...) мы преобразуем каждую подстроку в целое число.
user_numbers = list(map(int, input("Введите список целых чисел, разделенных пробелами: ").split()))

# Шаг №2. - Лямбда-функции для фильтрации четных и нечетных чисел:
# Мы определяем две лямбда-функции:
#       filter_even: возвращает True для четных чисел (x % 2 == 0).
#       filter_odd: возвращает True для нечетных чисел (x % 2 != 0).
filter_even = lambda x: x % 2 == 0
filter_odd = lambda x: x % 2 != 0

# Шаг №3. - Фильтрация и вывод результатов:
# Мы используем функцию filter вместе с соответствующей лямбда-функцией для фильтрации списка целых чисел.
# Результаты преобразуются в списки с помощью list.
# Мы выводим списки четных и нечетных чисел с использованием print.

even_numbers = list(filter(filter_even, user_numbers))
odd_numbers = list(filter(filter_odd, user_numbers))

print("Список четных чисел:", even_numbers)
print("Список нечетных чисел:", odd_numbers)

# Теперь, этот код позволяет пользователю ввести список целых чисел, а затем
# выводит два списка: четных и нечетных чисел.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №3. - фильтрует список целых чисел, заданных пользователем;
# Список целых чисел: [78, 2, 13, 46, 5, 61, 74, 81, 94, 10]
# Список четных чисел: [78, 2, 46, 74, 94, 10]
# Список нечетных чисел: [13, 5, 61, 81]
# Вариант №2. (Решение данного пункта в задании) ↓ - как мне показалось более сложный (не текущем уровне знаний Python)

# Получение списка целых чисел от пользователя
user_numbers = list(map(int, input("Введите список целых чисел, разделенных пробелами: ").split()))
# Запрос у пользователя типа фильтрации (все, положительные, отрицательные)
filter_type = input("Выберите тип фильтрации (all/positive/negative): ").lower()
# Лямбда-функция для фильтрации чисел в зависимости от выбранного типа
filter_function = (
    lambda x: True,                        # Все числа
    lambda x: x > 0,                       # Положительные числа
    lambda x: x < 0                        # Отрицательные числа
)[["all", "positive", "negative"].index(filter_type)]
# Фильтрация и вывод результатов
filtered_numbers = list(filter(filter_function, user_numbers))
print(f"Список {filter_type} чисел:", filtered_numbers)

# Теперь снова шаг за шагом:
# Шаг №1. - Получение списка целых чисел от пользователя:
# Мы используем функцию input, чтобы запросить у пользователя ввод целых чисел, разделенных пробелами.
# input() возвращает строку, которую мы разбиваем с помощью метода split().
# С помощью map(int, ...) мы преобразуем каждую подстроку в целое число.
user_numbers = list(map(int, input("Введите список целых чисел, разделенных пробелами: ").split()))

# Шаг №2. - Запрос у пользователя типа фильтрации:
# Мы используем функцию input для запроса у пользователя выбора типа фильтрации (все числа, положительные,
# отрицательные).
# Результат сохраняется в переменной filter_type.
filter_type = input("Выберите тип фильтрации (all/positive/negative): ").lower()

# Шаг №3. - Лямбда-функция для фильтрации чисел в зависимости от выбранного типа:
# Мы создаем кортеж из трех лямбда-функций, каждая из которых представляет разные типы фильтрации: все числа,
# положительные числа, отрицательные числа.
# Мы используем index(filter_type) для выбора нужной функции в зависимости от ввода пользователя.
# Полученная функция сохраняется в переменной filter_function.
filter_function = (
    lambda x: True,               # Все числа
    lambda x: x > 0,              # Положительные числа
    lambda x: x < 0               # Отрицательные числа
)[["all", "positive", "negative"].index(filter_type)]

# Шаг №4. - Фильтрация и вывод результатов:
# Мы используем функцию filter вместе с filter_function для фильтрации списка целых чисел.
# Результаты преобразуются в список с помощью list.
# Мы выводим отфильтрованный список с использованием print.
filtered_numbers = list(filter(filter_function, user_numbers))
print(f"Список {filter_type} чисел:", filtered_numbers)

# Вот этот код, более сложный вариант, который позволяет пользователю вводить список целых чисел и выбирать,
# какие числа он хочет отфильтровать (все, положительные, отрицательные).
# В результате программа выводит отфильтрованный список в соответствии с выбором пользователя.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №3. - фильтрует список целых чисел, заданных пользователем;
# Список целых чисел: [78, 2, 13, 46, 5, 61, 74, 81, 94, 10]
# Список четных чисел: [78, 2, 46, 74, 94, 10]
# Список нечетных чисел: [13, 5, 61, 81]
# Вариант №3. (Решение данного пункта в задании) ↓

def get_valid_integer_list():
    while True:
        user_input = input("Введите список целых чисел, разделенных пробелами: ")
        try:
            numbers = list(map(int, user_input.split()))
            return numbers
        except ValueError:
            print("Ошибка! Введите корректный список целых чисел.")
# Получение списка целых чисел от пользователя
user_numbers = get_valid_integer_list()
# Фильтрация и вывод результатов
even_numbers = list(filter(lambda x: x % 2 == 0, user_numbers))
odd_numbers = list(filter(lambda x: x % 2 != 0, user_numbers))

print("Список четных чисел:", even_numbers)
print("Список нечетных чисел:", odd_numbers)

# Шаг №1. - Определение функции get_valid_integer_list:
# Функция используется для получения от пользователя списка целых чисел.
# Ввод пользователя разделяется пробелами, и каждая подстрока преобразуется в целое число с помощью map(int, ...).
# Если во время преобразования возникает ошибка (ValueError), программа выводит сообщение об ошибке
# и запрашивает ввод заново.
def get_valid_integer_list():
    while True:
        user_input = input("Введите список целых чисел, разделенных пробелами: ")
        try:
            numbers = list(map(int, user_input.split()))
            return numbers
        except ValueError:
            print("Ошибка! Введите корректный список целых чисел.")

# Шаг №2. - Получение списка целых чисел от пользователя:
# Вызывается функция get_valid_integer_list, которая запрашивает у пользователя ввод и возвращает список целых чисел.
user_numbers = get_valid_integer_list()

# Шаг №3. - Фильтрация и вывод результатов:
# Создаются две лямбда-функции: одна фильтрует четные числа (lambda x: x % 2 == 0), другая - нечетные
# (lambda x: x % 2 != 0). Используется функция filter для фильтрации списка пользовательских чисел в соответствии
# с заданными лямбда-функциями. Результаты преобразуются в списки и выводятся.
even_numbers = list(filter(lambda x: x % 2 == 0, user_numbers))
odd_numbers = list(filter(lambda x: x % 2 != 0, user_numbers))

print("Список четных чисел:", even_numbers)
print("Список нечетных чисел:", odd_numbers)

#######################################################################################################################
#######################################################################################################################
#######################################################################################################################

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №4. - выводит год, месяц, дату и время. При решении используйте модуль datetime
# Output:
# 2022-07-19 07:58:31.246609
# 2022
# 7
# 19
# 07:58:31.246609

# Вариант №1.
from datetime import datetime
# Лямбда-функция для вывода года, месяца, даты и времени
print_datetime = lambda: (
    datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3],
    datetime.now().year,
    datetime.now().month,
    datetime.now().day,
    datetime.now().strftime("%H:%M:%S.%f")[:-3]
)
# Вызов лямбда-функции и вывод результатов
full_datetime, year, month, day, time = print_datetime()
print("Output:")
print(full_datetime)
print(year)
print(month)
print(day)
print(time)

# Шаг №1. - Импорт модуля datetime:
# Мы импортируем модуль datetime для работы с датой и временем.
from datetime import datetime

# Шаг №2. - Определение лямбда-функции print_datetime:
# Лямбда-функция использует datetime.now() для получения текущей даты и времени.
# С помощью strftime форматируем дату и время в строку.
# Отсекаем последние три символа (миллисекунды) для соответствия ожидаемому выводу.
print_datetime = lambda: (
    datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3],
    datetime.now().year,
    datetime.now().month,
    datetime.now().day,
    datetime.now().strftime("%H:%M:%S.%f")[:-3]
)

# Шаг №3. - Вызов лямбда-функции и распаковка результатов:
# Вызываем лямбда-функцию и распаковываем результаты в переменные full_datetime, year, month, day, time.
full_datetime, year, month, day, time = print_datetime()

# Шаг №4. - Вывод результатов: Выводим результаты на экран.
print("Output:")
print(full_datetime)
print(year)
print(month)
print(day)
print(time)

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №4. - выводит год, месяц, дату и время. При решении используйте модуль datetime
# Output:
# 2022-07-19 07:58:31.246609
# 2022
# 7
# 19
# 07:58:31.246609

# Вариант №2.

from datetime import datetime
# Лямбда-функция для форматированного вывода
format_and_print = lambda dt: (
    print(f"{dt:%Y-%m-%d %H:%M:%S.%f}"[:-3]),
    print(dt.year),
    print(dt.month),
    print(dt.day),
    print(f"{dt:%H:%M:%S.%f}"[:-3])
)
# Вызов лямбда-функции и передача текущей даты и времени
format_and_print(datetime.now())

# Шаг №1. - Импорт модуля datetime: - импортируем модуль datetime для работы с датой и временем.
from datetime import datetime

# Шаг №2. - Определение лямбда-функции format_and_print:
# Лямбда-функция принимает объект datetime и использует f-строку для форматирования и вывода различных
# частей даты и времени.
# Обратите внимание, что %Y, %m, %d, %H, %M, %S, %f - это форматные строки для представления года,
# месяца, дня, часа, минут, секунд и миллисекунд соответственно.
# [:-3] используется для обрезки последних трех символов (миллисекунд).
format_and_print = lambda dt: (
    print(f"{dt:%Y-%m-%d %H:%M:%S.%f}"[:-3]),
    print(dt.year),
    print(dt.month),
    print(dt.day),
    print(f"{dt:%H:%M:%S.%f}"[:-3])
)

# Шаг №3. - Вызов лямбда-функции и передача текущей даты и времени:
# Создаем объект datetime с текущей датой и временем, затем вызываем лямбда-функцию, передавая этот объект.
format_and_print(datetime.now())

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1. Пункт №4. - выводит год, месяц, дату и время. При решении используйте модуль datetime
# Output:
# 2022-07-19 07:58:31.246609
# 2022
# 7
# 19
# 07:58:31.246609

# Вариант №3.

from datetime import datetime
# Лямбда-функция для форматированного вывода
format_and_print = lambda dt: print(f"{dt:%Y-%m-%d %H:%M:%S.%f}"[:-3], dt.year, dt.month, dt.day, f"{dt:%H:%M:%S.%f}"[:-3])
# Вызов лямбда-функции и передача текущей даты и времени
format_and_print(datetime.now())

# Шаг №1. - Импорт модуля datetime: Мы импортируем модуль datetime для работы с датой и временем.
from datetime import datetime

# Шаг №2. - Определение лямбда-функции format_and_print:
# Лямбда-функция принимает объект datetime и использует f-строку для форматирования и вывода различных частей
# даты и времени.
# Обратите внимание, что %Y, %m, %d, %H, %M, %S, %f - это форматные строки для представления года, месяца, дня, часа,
# минут, секунд и миллисекунд соответственно.
# [:-3] используется для обрезки последних трех символов (миллисекунд).
format_and_print = lambda dt: print(f"{dt:%Y-%m-%d %H:%M:%S.%f}"[:-3], dt.year, dt.month, dt.day, f"{dt:%H:%M:%S.%f}"[:-3])

# Шаг №3. - Вызов лямбда-функции и передача текущей даты и времени: Создаем объект datetime с текущей датой и временем,
# затем вызываем лямбда-функцию, передавая этот объект.
format_and_print(datetime.now())

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# Напишите функцию, которая принимает один аргумент для лямбды функции и этот аргумент будет умножен
# на неизвестное заданное число.
# Input: 15             Output:
#                       Удвоенное значение 15 = 30
#                       Утроенное значение 15 = 45

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

def multiplier_function(factor):
    return lambda x: (f"Удвоенное значение {x} = {2 * x}", f"Утроенное значение {x} = {3 * x}")
# Пример использования
input_number = 15
multiply = multiplier_function(3)  # Задаем неизвестное заданное число, например, 3
# Вызываем лямбда-функцию и выводим результаты
result_double, result_triple = multiply(input_number)
print(result_double)
print(result_triple)

# Шаг №1. - Определение функции multiplier_function:
def multiplier_function(factor):
    return lambda x: (f"Удвоенное значение {x} = {2 * x}", f"Утроенное значение {x} = {3 * x}")
# Функция multiplier_function принимает один параметр factor.
# Внутри функции создается и возвращается лямбда-функция. Эта лямбда-функция принимает один аргумент x.
# Лямбда-функция возвращает кортеж строк, где первая строка содержит удвоенное значение x,
# а вторая строка содержит утроенное значение x.

# Шаг №2. - Пример использования функции:
input_number = 15
multiply = multiplier_function(3)  # Задаем неизвестное заданное число, например, 3
# Создается переменная input_number и устанавливается равной 15.
# Вызывается функция multiplier_function с аргументом 3, и результат сохраняется в переменной multiply.
# Теперь переменная multiply является лямбда-функцией, которая умножает свой аргумент на 3
# (в соответствии с переданным аргументом factor).

# Шаг №3. - Вызов лямбда-функции и вывод результатов:
result_double, result_triple = multiply(input_number)
print(result_double)
print(result_triple)
# Вызывается лямбда-функция, которая была возвращена функцией multiplier_function. Аргумент input_number равен 15.
# Результат вызова лямбда-функции - кортеж строк с удвоенным и утроенным значением input_number.
# Эти результаты выводятся на экран с помощью print.

# Шаг №4. - Вывод программы:
Удвоенное значение 15 = 30
Утроенное значение 15 = 45

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓
def multiplier_function(factor):
    return lambda x: (f"Удвоенное значение {x} = {2 * x}", f"Утроенное значение {x} = {3 * x}")
# Запрос ввода числа от пользователя
input_number = int(input("Введите число: "))
# Вызываем лямбда-функцию и выводим результаты
multiply = multiplier_function(3)  # Задаем неизвестное заданное число, например, 3
result_double, result_triple = multiply(input_number)
print(result_double)
print(result_triple)

# Шаг №1. - Определение функции multiplier_function:
def multiplier_function(factor):
    return lambda x: (f"Удвоенное значение {x} = {2 * x}", f"Утроенное значение {x} = {3 * x}")
# Функция multiplier_function принимает один параметр factor.
# Внутри функции создается и возвращается лямбда-функция. Эта лямбда-функция принимает один аргумент x.
# Лямбда-функция возвращает кортеж строк, где первая строка содержит удвоенное значение x, а вторая строка
# содержит утроенное значение x.

# Шаг №2. - Запрос ввода числа от пользователя:
input_number = int(input("Введите число: "))
# Программа запрашивает у пользователя ввод числа с помощью input.
# Введенная строка преобразуется в целое число с помощью int() и сохраняется в переменной input_number.

# Шаг №3. - Вызов лямбда-функции и вывод результатов:
multiply = multiplier_function(3)  # Задаем неизвестное заданное число, например, 3
result_double, result_triple = multiply(input_number)
print(result_double)
print(result_triple)
# Создается переменная multiply, которой присваивается лямбда-функция, созданная вызовом multiplier_function(3).
# Лямбда-функция теперь умножает свой аргумент на 3.
# Вызывается лямбда-функция с аргументом input_number, введенным пользователем.
# Результаты умножения на 2 и 3 выводятся на экран с помощью print.

# Шаг №4. - Вывод программы:
Удвоенное значение 5 = 10
Утроенное значение 5 = 15


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №3.

# Дано: ↓

# Напишите программу, используя лямбда-функции для подсчета четных и нечетных чисел в списке целых чисел.
# Output:
# Список целых чисел
# [147, 241, 39, 5, 778, 18, 0, 10]
# Количество четных чисел: 4
# Количество нечетных чисел: 4

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

# Список целых чисел
numbers = [147, 241, 39, 5, 778, 18, 0, 10]
# Лямбда-функции для проверки четности и нечетности числа
is_even = lambda x: x % 2 == 0
is_odd = lambda x: x % 2 != 0
# Используем функцию filter и лямбда-функции для отфильтровывания четных и нечетных чисел
even_numbers = list(filter(is_even, numbers))
odd_numbers = list(filter(is_odd, numbers))
# Вывод результата
print("Список целых чисел:")
print(numbers)
print("\nКоличество четных чисел:", len(even_numbers))
print("Количество нечетных чисел:", len(odd_numbers))

# Шаг №1. - Создание списка целых чисел:
numbers = [147, 241, 39, 5, 778, 18, 0, 10]
# В этой строке создается список numbers, содержащий целые числа.

# Шаг №2. - Определение лямбда-функций для проверки четности и нечетности:
is_even = lambda x: x % 2 == 0
is_odd = lambda x: x % 2 != 0
# Здесь определяются две лямбда-функции: is_even возвращает True, если число четное, и False в противном случае;
# is_odd возвращает True, если число нечетное, и False в противном случае.

# Шаг №3. - Использование функции filter с лямбда-функциями:
even_numbers = list(filter(is_even, numbers))
odd_numbers = list(filter(is_odd, numbers))
# filter используется для отфильтровывания четных и нечетных чисел из списка numbers с использованием соответствующих
# лямбда-функций.
# Результаты сохраняются в переменные even_numbers и odd_numbers.

# Шаг №4. - Вывод результата:
print("Список целых чисел:")
print(numbers)
print("\nКоличество четных чисел:", len(even_numbers))
print("Количество нечетных чисел:", len(odd_numbers))
# Здесь выводится исходный список чисел, количество четных чисел и количество нечетных чисел.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓

# Запрос ввода чисел от пользователя
input_numbers = input("Введите целые числа, разделенные запятой: ")
# Разбиваем строку на числа и преобразуем в список целых чисел
numbers = [int(num.strip()) for num in input_numbers.split(',')]
# Лямбда-функции для проверки четности и нечетности числа
is_even = lambda x: x % 2 == 0
is_odd = lambda x: x % 2 != 0
# Используем функцию filter и лямбда-функции для отфильтровывания четных и нечетных чисел
even_numbers = list(filter(is_even, numbers))
odd_numbers = list(filter(is_odd, numbers))
# Вывод результата
print("\nСписок целых чисел:")
print(numbers)
print("\nКоличество четных чисел:", len(even_numbers))
print("Количество нечетных чисел:", len(odd_numbers))

# Шаг №1. - Запрос ввода чисел от пользователя:
input_numbers = input("Введите целые числа, разделенные запятой: ")
# Эта строка запрашивает у пользователя ввод целых чисел. Введенные числа должны быть разделены запятой.

# Шаг №2. - Преобразование введенной строки в список целых чисел:
numbers = [int(num.strip()) for num in input_numbers.split(',')]
# input_numbers.split(',') разбивает введенную строку на части, используя запятую в качестве разделителя.
# int(num.strip()) преобразует каждую часть в целое число, удаляя лишние пробелы с помощью strip().
# Результат сохраняется в переменной numbers, которая представляет собой список целых чисел.

# Шаг №3. - Лямбда-функции для проверки четности и нечетности числа:
is_even = lambda x: x % 2 == 0
is_odd = lambda x: x % 2 != 0
# Эти строки определяют две лямбда-функции: is_even возвращает True, если число четное, и False в
# противном случае; is_odd возвращает True, если число нечетное, и False в противном случае.

# Шаг №4. - Использование функции filter с лямбда-функциями:
even_numbers = list(filter(is_even, numbers))
odd_numbers = list(filter(is_odd, numbers))
# filter(is_even, numbers) фильтрует четные числа из списка numbers с использованием функции is_even.
# filter(is_odd, numbers) фильтрует нечетные числа из списка numbers с использованием функции is_odd.
# Результаты сохраняются в переменных even_numbers и odd_numbers.

# Шаг №5. - Вывод результата:
print("\nСписок целых чисел:")
print(numbers)
print("\nКоличество четных чисел:", len(even_numbers))
print("Количество нечетных чисел:", len(odd_numbers))
# Этот блок кода выводит исходный список чисел и количество четных и нечетных чисел.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓

# Запрос ввода чисел от пользователя и преобразование в список целых чисел
numbers = list(map(int, input("Введите целые числа, разделенные запятой: ").split(',')))
# Использование лямбда-функций для проверки четности и нечетности числа
is_even = lambda x: x % 2 == 0
is_odd = lambda x: x % 2 != 0
# Использование функции count для подсчета четных и нечетных чисел
even_count = sum(map(is_even, numbers))
odd_count = sum(map(is_odd, numbers))
# Вывод результата
print("\nСписок целых чисел:")
print(numbers)
print("\nКоличество четных чисел:", even_count)
print("Количество нечетных чисел:", odd_count)

# Шаг №1. - Запрос ввода чисел от пользователя и преобразование в список целых чисел:
numbers = list(map(int, input("Введите целые числа, разделенные запятой: ").split(',')))
# input("Введите целые числа, разделенные запятой: ") запрашивает у пользователя ввод чисел.
# .split(',') разбивает введенную строку на части, используя запятую в качестве разделителя.
# map(int, ...) применяет функцию int к каждой части, преобразуя ее в целое число.
# list(...) преобразует результаты в список.

# Шаг №2. - Использование лямбда-функций для проверки четности и нечетности числа:
is_even = lambda x: x % 2 == 0
is_odd = lambda x: x % 2 != 0
# Эти лямбда-функции определяют условия четности и нечетности числа.

# Шаг №3. - Использование функции count для подсчета четных и нечетных чисел:
even_count = sum(map(is_even, numbers))
odd_count = sum(map(is_odd, numbers))
# map(is_even, numbers) применяет лямбда-функцию is_even к каждому числу в списке, создавая список булевых значений.
# sum(...) суммирует булевы значения, где True считается как 1, а False как 0.
# even_count и odd_count содержат количество четных и нечетных чисел соответственно.

# Шаг №4. - Вывод результата:
print("\nСписок целых чисел:")
print(numbers)
print("\nКоличество четных чисел:", even_count)
print("Количество нечетных чисел:", odd_count)
# Этот блок кода выводит исходный список чисел и количество четных и нечетных чисел.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# МОДУЛИ и ПАКЕТЫ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №1.

# Дано: ↓

# Напишите программу, в которой необходимо создать массив 10x10 со случайными значениями и найдите минимальное
# и максимальное значения.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

import numpy as np
# Создание массива 10x10 со случайными значениями от 0 до 100
array_10x10 = np.random.randint(0, 100, size=(10, 10))
# Нахождение минимального и максимального значений
min_value = np.min(array_10x10)
max_value = np.max(array_10x10)
# Вывод результатов
print("Массив 10x10 со случайными значениями:")
print(array_10x10)
print("\nМинимальное значение:", min_value)
print("Максимальное значение:", max_value)

# Шаг №1. - Импорт библиотеки numpy:
import numpy as np
# Эта строка импортирует библиотеку numpy и присваивает ей псевдоним np.
# Псевдоним np широко используется для краткости кода при работе с numpy.

# Шаг №2. - Создание массива 10x10 со случайными значениями:
array_10x10 = np.random.randint(0, 100, size=(10, 10))
# np.random.randint(0, 100, size=(10, 10)) создает массив размером 10x10,
# заполненный случайными целыми числами в диапазоне от 0 (включительно) до 100 (исключительно).

# Шаг №3. - Нахождение минимального и максимального значений:
min_value = np.min(array_10x10)
max_value = np.max(array_10x10)
# np.min(array_10x10) находит минимальное значение в массиве array_10x10.
# np.max(array_10x10) находит максимальное значение в массиве array_10x10.

# Шаг №4. - Вывод результатов:
print("Массив 10x10 со случайными значениями:")
print(array_10x10)
print("\nМинимальное значение:", min_value)
print("Максимальное значение:", max_value)
# Этот блок кода выводит массив array_10x10 и найденные минимальное и максимальное значения.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓

import numpy as np

def generate_random_array(rows, cols, min_val=0, max_val=100):
    """
    Генерация массива заданного размера со случайными значениями.

    Parameters:
    - rows (int): Количество строк в массиве.
    - cols (int): Количество столбцов в массиве.
    - min_val (int): Минимальное значение для случайных чисел (по умолчанию 0).
    - max_val (int): Максимальное значение для случайных чисел (по умолчанию 100).

    Returns:
    - np.ndarray: Сгенерированный массив.
    """
    return np.random.randint(min_val, max_val, size=(rows, cols))

def find_min_max_values(array):
    """
    Нахождение минимального и максимального значений в массиве.

    Parameters:
    - array (np.ndarray): Входной массив.

    Returns:
    - int: Минимальное значение в массиве.
    - int: Максимальное значение в массиве.
    """
    min_val = np.min(array)
    max_val = np.max(array)
    return min_val, max_val

def print_results(array, min_val, max_val):
    """
    Вывод результатов на экран.

    Parameters:
    - array (np.ndarray): Входной массив.
    - min_val (int): Минимальное значение в массиве.
    - max_val (int): Максимальное значение в массиве.
    """
    print("Массив:")
    print(array)
    print("\nМинимальное значение:", min_val)
    print("Максимальное значение:", max_val)

def main():
    # Генерация массива 10x10
    array_10x10 = generate_random_array(10, 10)

    # Нахождение минимального и максимального значений
    min_value, max_value = find_min_max_values(array_10x10)

    # Вывод результатов
    print_results(array_10x10, min_value, max_value)

if __name__ == "__main__":
    main()

# Шаг №1. - Импорт библиотеки numpy:
import numpy as np
# Эта строка импортирует библиотеку numpy и присваивает ей псевдоним np.

# Шаг №2. - Определение функции generate_random_array:
def generate_random_array(rows, cols, min_val=0, max_val=100):
    return np.random.randint(min_val, max_val, size=(rows, cols))
# Функция generate_random_array принимает параметры rows (количество строк), cols (количество столбцов), min_val
# (минимальное значение для случайных чисел, по умолчанию 0) и max_val (максимальное значение для случайных чисел,
# по умолчанию 100).
# Возвращает массив размером (rows, cols), заполненный случайными целыми числами в диапазоне [min_val, max_val).

# Шаг №3. - Определение функции find_min_max_values:
def find_min_max_values(array):
    min_val = np.min(array)
    max_val = np.max(array)
    return min_val, max_val
# Функция find_min_max_values принимает массив array.
# Возвращает минимальное и максимальное значения в массиве.

# Шаг №4. - Определение функции print_results:
def print_results(array, min_val, max_val):
    print("Массив:")
    print(array)
    print("\nМинимальное значение:", min_val)
    print("Максимальное значение:", max_val)
# Функция print_results принимает массив array, минимальное значение min_val и максимальное значение max_val.
# Выводит массив и найденные значения на экран.

# Шаг №5. - Определение функции main:
def main():
    array_10x10 = generate_random_array(10, 10)
    min_value, max_value = find_min_max_values(array_10x10)
    print_results(array_10x10, min_value, max_value)
# Функция main вызывает остальные функции для выполнения основной логики программы.

# Шаг №6. - Запуск программы:
if __name__ == "__main__":
    main()
# Этот блок проверяет, является ли текущий файл основным (а не модулем, импортированным в другой файл).
# Если это так, то выполняется функция main().

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓ - Мне было скучно и я начал выдумывать: "а можно как то визуализировать сие чудо?"... Ну и нашел способ
# добавить интересные элементы, такие как создание цветной визуализации массива с использованием библиотеки matplotlib.
# Для этого необходимо установить matplotlib с помощью pip install matplotlib.

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize

def generate_random_array(rows, cols, min_val=0, max_val=100):
    return np.random.randint(min_val, max_val, size=(rows, cols))

def find_min_max_values(array):
    min_val = np.min(array)
    max_val = np.max(array)
    return min_val, max_val

def print_results(array, min_val, max_val):
    print("Массив:")
    print(array)
    print("\nМинимальное значение:", min_val)
    print("Максимальное значение:", max_val)

def visualize_array(array):
    norm = Normalize(vmin=np.min(array), vmax=np.max(array))
    plt.imshow(array, cmap='viridis', norm=norm)
    plt.colorbar(label='Значение')
    plt.title('Визуализация массива')
    plt.show()

def main():
    array_10x10 = generate_random_array(10, 10)
    min_value, max_value = find_min_max_values(array_10x10)
    print_results(array_10x10, min_value, max_value)
    visualize_array(array_10x10)

if __name__ == "__main__":
    main()

# Шаг №1. - Импорт библиотек:
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
# numpy используется для работы с массивами.
# matplotlib.pyplot используется для создания графиков и визуализации данных.
# Normalize из matplotlib.colors используется для нормализации значений в массиве при создании цветовой карты.

# Шаг №2. - Определение функции generate_random_array:
def generate_random_array(rows, cols, min_val=0, max_val=100):
    return np.random.randint(min_val, max_val, size=(rows, cols))
# Эта функция генерирует массив случайных целых чисел размером (rows, cols) в диапазоне [min_val, max_val).

# Шаг №3. - Определение функции find_min_max_values:
def find_min_max_values(array):
    min_val = np.min(array)
    max_val = np.max(array)
    return min_val, max_val
# Эта функция находит минимальное и максимальное значения в массиве.

# Шаг №4. - Определение функции print_results:
def print_results(array, min_val, max_val):
    print("Массив:")
    print(array)
    print("\nМинимальное значение:", min_val)
    print("Максимальное значение:", max_val)
# Эта функция выводит массив, минимальное и максимальное значения на экран.

# Шаг №5. - Определение функции visualize_array:
def visualize_array(array):
    norm = Normalize(vmin=np.min(array), vmax=np.max(array))
    plt.imshow(array, cmap='viridis', norm=norm)
    plt.colorbar(label='Значение')
    plt.title('Визуализация массива')
    plt.show()
# Эта функция создает цветную визуализацию массива с использованием matplotlib.
# Normalize используется для нормализации значений в массиве от минимального до максимального перед созданием
# цветовой карты.
# plt.imshow отображает массив, plt.colorbar добавляет цветовую шкалу, и plt.title устанавливает заголовок.

# Шаг №6. - Определение функции main:
def main():
    array_10x10 = generate_random_array(10, 10)
    min_value, max_value = find_min_max_values(array_10x10)
    print_results(array_10x10, min_value, max_value)
    visualize_array(array_10x10)
# Эта функция вызывает остальные функции для выполнения основной логики программы.

# Шаг №7. - Запуск программы:
if __name__ == "__main__":
    main()
# Этот блок проверяет, является ли текущий файл основным (а не модулем, импортированным в другой файл).
# Если это так, то выполняется функция main().


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №2.

# Дано: ↓

# Напишите программу, создайте случайный вектор размера 30 и найдите среднее значение.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

import numpy as np
# Создание случайного вектора размера 30
random_vector = np.random.rand(30)
# Нахождение среднего значения
mean_value = np.mean(random_vector)
# Вывод результатов
print("Случайный вектор:")
print(random_vector)
print("\nСреднее значение:", mean_value)

# Шаг №1. - Импорт библиотеки numpy:
import numpy as np
# Эта строка импортирует библиотеку numpy и присваивает ей псевдоним np.

# Шаг №2. - Создание случайного вектора размера 30:
random_vector = np.random.rand(30)
# np.random.rand(30) создает вектор из 30 случайных чисел в диапазоне от 0 до 1.

# Шаг №3. - Нахождение среднего значения:
mean_value = np.mean(random_vector)
# np.mean(random_vector) вычисляет среднее значение для элементов вектора.

# Шаг №4. - Вывод результатов:
print("Случайный вектор:")
print(random_vector)
print("\nСреднее значение:", mean_value)
# Выводится созданный случайный вектор и найденное среднее значение.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓

import random
# Создание случайного вектора размера 30
random_vector = [random.random() for _ in range(30)]
# Нахождение среднего значения
mean_value = sum(random_vector) / len(random_vector)
# Вывод результатов
print("Случайный вектор:")
for value in random_vector:
    print(value)
print("\nСреднее значение:", mean_value)

# Шаг №1. - Импорт библиотеки numpy:
import random
# Эта строка импортирует модуль random, который мы будем использовать для создания случайных чисел.

# Шаг №2. - Создание случайного вектора размера 30:
random_vector = [random.random() for _ in range(30)]
# random_vector - это список, который создается с использованием генератора списка.
# Генератор списка [random.random() for _ in range(30)] создает список из 30 случайных чисел, где каждый
# элемент - результат вызова random.random(), который возвращает случайное число от 0.0 до 1.0.

# Шаг №3. - Нахождение среднего значения:
mean_value = sum(random_vector) / len(random_vector)
# sum(random_vector) вычисляет сумму всех элементов вектора.
# len(random_vector) возвращает количество элементов вектора.
# sum(random_vector) / len(random_vector) вычисляет среднее значение (среднее арифметическое) элементов вектора.

# Шаг №4. - Вывод результатов:
print("Случайный вектор:")
for value in random_vector:
    print(value)

print("\nСреднее значение:", mean_value)

# print("Случайный вектор:") выводит заголовок "Случайный вектор:".
# for value in random_vector: запускает цикл, который проходит по каждому элементу вектора.
# print(value) выводит каждый элемент вектора на новой строке.
# print("\nСреднее значение:", mean_value) выводит заголовок "Среднее значение:" и среднее значение, вычисленное ранее.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №3. ↓

import random
def generate_random_vector(size):
    # Генерация случайного вектора
    return [random.random() for _ in range(size)]
def calculate_mean(vector):
    # Вычисление среднего значения без использования sum и len
    total = count = 0
    for value in vector:
        total += value
        count += 1
    return total / count
def main():
    vector_size = 30
    # Создание случайного вектора размера 30
    random_vector = generate_random_vector(vector_size)
    # Нахождение среднего значения без использования sum и len
    mean_value = calculate_mean(random_vector)
    # Вывод результатов
    print("Случайный вектор:")
    print(random_vector)
    print("\nСреднее значение:", mean_value)

if __name__ == "__main__":
    main()

# Шаг №1. - Импорт модуля random:
import random
# Эта строка импортирует модуль random, который мы будем использовать для создания случайных чисел.

# Шаг №2. - Определение функции generate_random_vector:
def generate_random_vector(size):
    return [random.random() for _ in range(size)]
# Эта функция генерирует случайный вектор заданного размера.

# Шаг №3. - Определение функции calculate_mean:
def calculate_mean(vector):
    total = count = 0
    for value in vector:
        total += value
        count += 1
    return total / count
# Эта функция вычисляет среднее значение вектора без использования стандартных функций sum и len.

# Шаг №4. - Определение функции main:
def main():
    vector_size = 30
    random_vector = generate_random_vector(vector_size)
    mean_value = calculate_mean(random_vector)
    print("Случайный вектор:")
    print(random_vector)
    print("\nСреднее значение:", mean_value)
# Эта функция вызывает остальные функции для выполнения основной логики программы.

# Шаг №5. - Запуск программы:
if __name__ == "__main__":
    main()
# Этот блок проверяет, является ли текущий файл основным (а не модулем, импортированным в другой файл).
# Если это так, то выполняется функция main().


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №3.

# Дано: ↓

# Создайте массив 2d с 1 на границе и 0 внутри.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

import numpy as np
def create_border_array(rows, cols):
    # Создание массива с единицами
    border_array = np.ones((rows, cols), dtype=int)
    # Установка внутренних элементов в нули
    border_array[1:-1, 1:-1] = 0

    return border_array
def main():
    # Задаем размеры массива
    rows, cols = 5, 8
    # Создание массива с 1 на границе и 0 внутри
    result_array = create_border_array(rows, cols)
    # Вывод результатов
    print(result_array)
if __name__ == "__main__":
    main()

# Шаг №1. - Импорт библиотеки numpy:
import numpy as np
# Эта строка импортирует библиотеку numpy и присваивает ей псевдоним np.

# Шаг №2. - Определение функции create_border_array:
def create_border_array(rows, cols):
    border_array = np.ones((rows, cols), dtype=int)
    border_array[1:-1, 1:-1] = 0
    return border_array
# np.ones((rows, cols), dtype=int) создает массив из единиц указанной формы.
# border_array[1:-1, 1:-1] = 0 устанавливает внутренние элементы массива в нули.

# Шаг №3. - Определение функции main:
def main():
    rows, cols = 5, 8
    result_array = create_border_array(rows, cols)
    print(result_array)
# Эта функция вызывает функцию create_border_array для создания массива и выводит его.

# Шаг №4. - Запуск программы:
if __name__ == "__main__":
    main()
# Этот блок проверяет, является ли текущий файл основным (а не модулем, импортированным в другой файл).
# Если это так, то выполняется функция main().

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓

import numpy as np
def create_border_array(rows, cols):
    return np.array([[1 if i == 0 or i == rows-1 or j == 0 or j == cols-1 else 0 for j in range(cols)] for i in range(rows)])
def main():
    rows, cols = 5, 8
    result_array = create_border_array(rows, cols)
    print(result_array)
if __name__ == "__main__":
    main()

# Шаг №1. - Импорт библиотеки numpy:
import numpy as np
# Эта строка импортирует библиотеку numpy и присваивает ей псевдоним np.

# Шаг №2. - Определение функции create_border_array с использованием тернарного оператора:
def create_border_array(rows, cols):
    return np.array([[1 if i == 0 or i == rows-1 or j == 0 or j == cols-1 else 0 for j in range(cols)] for i in range(rows)])
# Эта функция создает массив 2D размером (rows, cols).
# Используется списковое включение внутри спискового включения для создания массива, где значение 1 устанавливается
# для элементов на границе, а значение 0 для внутренних элементов.
# В тернарном операторе 1 if i == 0 or i == rows-1 or j == 0 or j == cols-1 else 0, проверяется, находится ли текущий
# элемент на границе или внутри.

# Шаг №3. - Определение функции main:
def main():
    rows, cols = 5, 8
    result_array = create_border_array(rows, cols)
    print(result_array)
# Эта функция вызывает функцию create_border_array для создания массива и выводит его.

# Шаг №4. - Запуск программы:
if __name__ == "__main__":
    main()
# Этот блок проверяет, является ли текущий файл основным (а не модулем, импортированным в другой файл).
# Если это так, то выполняется функция main().


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №4.

# Дано: ↓

# Создайте матрицу 5x5 со значениями 1,2,3,4 чуть ниже диагонали.

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

import numpy as np

def create_matrix_below_diagonal(size):
    matrix = np.zeros((size, size), dtype=int)
    for i in range(size - 1):
        matrix[i + 1:, i] = np.arange(1, size - i)
    return matrix

def main():
    matrix_size = 5
    result_matrix = create_matrix_below_diagonal(matrix_size)
    print(result_matrix)

if __name__ == "__main__":
    main()

# Шаг №1. - Импорт библиотеки numpy:
import numpy as np
# Эта строка импортирует библиотеку numpy и присваивает ей псевдоним np.

# Шаг №2. - Определение функции create_matrix_below_diagonal:
def create_matrix_below_diagonal(size):
    matrix = np.zeros((size, size), dtype=int)
    for i in range(size - 1):
        matrix[i + 1:, i] = np.arange(1, size - i)
    return matrix
# np.zeros((size, size), dtype=int) создает матрицу размером (size, size) из нулей.
# С использованием цикла for и функции np.arange, значения от 1 до size - i устанавливаются чуть ниже
# диагонали для каждой строки.

# Шаг №3. - Определение функции main:
def main():
    matrix_size = 5
    result_matrix = create_matrix_below_diagonal(matrix_size)
    print(result_matrix)
# Эта функция вызывает функцию create_matrix_below_diagonal для создания матрицы и выводит ее.

# Шаг №4. - Запуск программы:
if __name__ == "__main__":
    main()
# Этот блок проверяет, является ли текущий файл основным (а не модулем, импортированным в другой файл).
# Если это так, то выполняется функция main().

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓

# Создание матрицы 5x5 с значениями 1, 2, 3, 4 чуть ниже диагонали
matrix = [[0 for _ in range(5)] for _ in range(5)]

for i in range(1, 5):
    for j in range(i):
        matrix[i][j] = i

# Вывод матрицы
for row in matrix:
    print(row)

# Шаг №1. - Инициализация матрицы 5x5:
matrix = [[0 for _ in range(5)] for _ in range(5)]
# matrix - это двумерный список (матрица) размером 5x5, инициализированный нулями.
# Для создания матрицы используется генератор списка, который создает список из 5 списков,
# каждый из которых состоит из 5 нулей.

# Шаг №2. - Установка значений 1, 2, 3, 4 чуть ниже диагонали:
for i in range(1, 5):
    for j in range(i):
        matrix[i][j] = i
# Внешний цикл for i in range(1, 5) идет по строкам матрицы, начиная со второй строки (индекс 1).
# Внутренний цикл for j in range(i) идет по элементам в пределах текущей строки (от 0 до i-1).
# Каждый элемент matrix[i][j] устанавливается равным значению i.
# Таким образом, значения 1, 2, 3, 4 устанавливаются чуть ниже диагонали.

# Шаг №3. - Вывод матрицы:
for row in matrix:
    print(row)
# Цикл for row in matrix проходит по каждой строке матрицы.
# Каждая строка выводится на экран.

# Шаг №4. - Пример вывода:
[0, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
[2, 2, 0, 0, 0]
[3, 3, 3, 0, 0]
[4, 4, 4, 4, 0]


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Задание №5.

# Дано: ↓

# Как получить все даты, соответствующие определенному месяцу и году? (Ноябрь 2023)
# - решил написать так а не "Август 2022"

# Решение:

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №1. ↓

from calendar import monthrange
from datetime import datetime, timedelta

def get_dates_in_month(year, month):
    start_date = datetime(year, month, 1)
    _, last_day = monthrange(year, month)
    end_date = datetime(year, month, last_day)
    all_dates = [start_date + timedelta(days=x) for x in range((end_date - start_date).days + 1)]
    return all_dates

def main():
    year = 2023
    month = 11  # Ноябрь
    dates_in_november_2023 = get_dates_in_month(year, month)

    for date in dates_in_november_2023:
        print(date)

if __name__ == "__main__":
    main()

# Шаг №1. - Импорт библиотек:
from datetime import datetime, timedelta
from calendar import monthrange
# Эти строки импортируют необходимые модули и функции.

# Шаг №2. - Определение функции get_dates_in_month:
def get_dates_in_month(year, month):
    start_date = datetime(year, month, 1)
    _, last_day = monthrange(year, month)
    end_date = datetime(year, month, last_day)
    all_dates = [start_date + timedelta(days=x) for x in range((end_date - start_date).days + 1)]
    return all_dates
# Эта функция создает начальную и конечную дату для указанного месяца и года.
# Генерирует список всех дат в указанном диапазоне.

# Шаг №3. - Определение функции main:
def main():
    year = 2023
    month = 11  # Ноябрь
    dates_in_november_2023 = get_dates_in_month(year, month)

    for date in dates_in_november_2023:
        print(date)
# Эта функция вызывает функцию get_dates_in_month и выводит все даты в указанном месяце и году.

# Шаг №4. - Запуск программы:
if __name__ == "__main__":
    main()
# Этот блок проверяет, является ли текущий файл основным (а не модулем, импортированным в другой файл).
# Если это так, то выполняется функция main().

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Вариант №2. ↓ - думаю, что это более правильный вариант!!

import calendar

# Заданный месяц и год
year = 2023
month = 11

# Получение календаря для заданного месяца и года
cal = calendar.monthcalendar(year, month)

# Итерация по неделям календаря
for week in cal:
    # Итерация по дням недели
    for day in week:
        # Если день недели не равен 0 (0 обозначает пустой день в календаре)
        if day != 0:
            # Форматирование даты и вывод
            date_str = f"{year}-{month:02d}-{day:02d}"
            print(date_str)

# Шаг №1. - Импорт модуля calendar:
import calendar
# Этот шаг импортирует модуль calendar, который предоставляет функции для работы с календарем.

# Шаг №2. - Определение месяца и года:
year = 2022
month = 8
# Здесь задаются переменные year (год) и month (месяц), которые вы хотите использовать для получения дат.

# Шаг №3. - Получение календаря:
cal = calendar.monthcalendar(year, month)
# Эта строка создает календарь для указанного месяца и года. cal - это список списков, представляющих дни месяца,
# где каждый внутренний список представляет неделю.

# Шаг №4. - Итерация по календарю и вывод дат:
for week in cal:
    for day in week:
        if day != 0:
            date_str = f"{year}-{month:02d}-{day:02d}"
            print(date_str)
# Внешний цикл for week in cal итерируется по неделям в календаре.
# Внутренний цикл for day in week итерируется по дням недели.
# Если день day не равен 0 (0 обозначает пустой день в календаре),
# форматируется строка с датой в формате "гггг-мм-дд" и выводится.





